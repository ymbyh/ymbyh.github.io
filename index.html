<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Camellia">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="douban.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Camellia</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ymbyh/" title="github">github</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=32717172&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/ymbyh/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="douban.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ymbyh/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-SpringAOP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/11/07/SpringAOP/" class="article-date">
  	<time datetime="2024-11-07T02:51:39.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/11/07/SpringAOP/">
        &#39;SpringAOP&#39;
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><hr>
<h2 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h2><h3 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h3><p>( Aspect Orient Programming ) 面向切面编程，是面向对象编程(OOP) 的一种补充。</p>
<p>在 Java 程序自上而下处理主业务时，也会经常处理一些和主业务逻辑无关的问题（比如在接收用户访问请求时，计算程序响应该请求的运行时间）。这些代码如果和主逻辑代码混淆，会导致后期难以维护。</p>
<p>AOP 就是将这些横切性问题和主逻辑解耦。保证开发者不修改主逻辑代码的前提下，能为系统中的业务组件添加删除、或复用某种功能。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP 的本质是修改业务组件实际执行方法的源代码。即代理类 A 封装了目标类 B ，外部调用 B 的目标方法时会被代理类 A 拦截，代理类 A 一方面执行切面逻辑，一方面把调用转发给目标类 B ，执行目标方法。</p>
<p>该过程是代理模式的实现，代理方式有以下两种：</p>
<ul>
<li><p><strong>静态 AOP</strong> ：在编译阶段对程序源代码进行修改，生成静态的 AOP 代理类（字节码文件已被修改）。性能更好。</p>
</li>
<li><p><strong>动态 AOP</strong> ：在运行阶段动态生成代理对象。灵活性更好。</p>
</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>Spring 中的 AOP 是通过动态代理实现的，有以下两种方式：</p>
<ul>
<li><strong>JDK 动态代理</strong></li>
</ul>
<p>利用反射机制生成一个实现代理接口的类，在调用具体方法前调用 InvokeHandler 来处理。</p>
<p>JDK 代理只能对实现接口的类生成代理。代理生成的是一个接口对象，因此代理类必须实现了接口，否则会抛出异常。</p>
<ul>
<li><strong>CGlib 动态代理</strong></li>
</ul>
<p>直接操作字节码对代理对象类的字节码文件加载并修改，生成子类来处理。</p>
<p>CGlib 代理针对类实现代理，对指定的类生成一个子类并覆盖其中的方法，因此不能代理 final 类。</p>
<hr>
<h2 id="AOP-注解详解"><a href="#AOP-注解详解" class="headerlink" title="AOP 注解详解"></a>AOP 注解详解</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对负责扫描组件的配置文件类(@Configuration) 添加 <code>@EnableAspectJAutoProxy</code> 注解，启用 AOP 功能。</p>
<p><strong>默认通过 JDK 动态代理方式进行织入。</strong>但必须代理一个实现接口的类，否则会抛出异常。</p>
<p>注解改为 <code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>：</p>
<p>通过 cglib 的动态代理方式进行织入。但如果拓展类的方法被 final 修饰，则织入无效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.company.project.service.Meal.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>对组件类(@component) 添加 <code>@Aspect</code> 注解，表示该类为切面类。</p>
<h4 id="增强类型"><a href="#增强类型" class="headerlink" title="增强类型"></a>增强类型</h4><p><strong>前置通知</strong></p>
<p>切面方法注解 <code>@Before</code> 表示目标方法调用前，执行该切面方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后置通知</strong></p>
<ul>
<li>切面方法注解 <code>@After</code> 表示目标方法返回或抛出异常后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterReturning</code> 只在目标方法返回后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterThrowing</code> 只在目标方法抛出异常后，执行该切面方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环绕通知</strong></p>
<p>切面方法注解 <code>@Around</code> 表示切面方法执行过程中，执行目标方法。</p>
<p>传入参数为 ProceedingJoinPoint 类对象，表示目标方法。在切面方法中调用其 proceed 方法来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">        pj.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切点声明"><a href="#切点声明" class="headerlink" title="切点声明"></a>切点声明</h4><p>在切面方法中需要声明切面方法要切入的目标方法，execution 指示器是我们定义切点时最主要使用的指示器。</p>
<p>格式为： <code>execution(返回数据类型 路径.类.方法(传入参数类型))</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>execution(* com.company.project.service.Meal.eat(..))</code></td>
<td>执行 Meal 类的 eat 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.eat(int,String))</code></td>
<td>执行 Meal 类的 eat(int,String) 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.*(..))</code></td>
<td>执行 Meal 类的所有方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（不包含子包）</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service..*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（包含子包）</td>
</tr>
<tr>
<td><code>execution(public * *(..))</code></td>
<td>执行所有目标类的所有 public 方法时切入</td>
</tr>
<tr>
<td><code>execution(* pre*(...))</code></td>
<td>执行所有目标类所有以 pre 为前缀的方法时切入</td>
</tr>
</tbody></table>
<p>还有一些其他指示器：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>within(com.company.project.service.*)</code></td>
<td>执行 service 包内的任意方法时切入</td>
</tr>
<tr>
<td><code>this(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的代理对象的任意方法时切入</td>
</tr>
<tr>
<td><code>target(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的目标对象的任意方法时切入</td>
</tr>
<tr>
<td><code>args(java.io.Serializable)</code></td>
<td>任何一个只接受一个参数，并且运行时所传入的参数是 Serializable 接口的方法</td>
</tr>
</tbody></table>
<ul>
<li>多个匹配条件之间使用链接符连接： <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</li>
<li>within 指示器表示可以选择的包，bean 指示器可以在切点中选择 bean 。</li>
</ul>
<p>如参数 <code>execution(String com.company.project.service.test1.IBuy.buy(double)) &amp;&amp; args(price) &amp;&amp; bean(girl)</code> </p>
<p>要求返回类型为 String ；参数类型为 double ；参数名为 price ；调用目标方法的 bean 名称为 girl 。</p>
<p><strong>简化代码</strong></p>
<p>对于类中要频繁要切入的目标方法，我们可以使用 <code>@Pointcut</code> 注解声明切点表达式，简化代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(String com.company.project.service.Meal.eat(double)) &amp;&amp; args(price) &amp;&amp; bean(people)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point2</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point2(price)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(ProceedingJoinPoint pj, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pj.proceed();</span><br><span class="line">            <span class="keyword">if</span> (price &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;can not afford&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;没有购买&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="常用-AOP"><a href="#常用-AOP" class="headerlink" title="常用 AOP"></a>常用 AOP</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p><code>@ControllerAdvice</code> &#x2F; <code>@RestControllerAdvice</code>: 标注当前类为所有 Controller 类服务</p>
</li>
<li><p><code>@ExceptionHandler</code>: 标注当前方法处理异常（默认处理 RuntimeException）<br><code>@ExceptionHandler(value = Exception.class)</code>: 处理所有异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleOtherException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;错误=%s,位置=%s&quot;</span>, e.toString(), e.getStackTrace()[<span class="number">0</span>].toString());</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.UNKNOWN_ERROR.getErrorCode(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(StreamPlatformException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleVenusException</span><span class="params">(StreamPlatformException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(e.getErrorCode(), e.getMessageToUser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(FormValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleFormValidationException</span><span class="params">(FormValidationException e)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        e.getResult().getAllErrors().forEach(objectError -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (objectError <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">                <span class="type">FieldError</span> <span class="variable">fieldError</span> <span class="operator">=</span> (FieldError) objectError;</span><br><span class="line">                message.append(<span class="string">&quot;参数&quot;</span>).append(fieldError.getField())</span><br><span class="line">                        .append(<span class="string">&quot;错误值为&quot;</span>).append(fieldError.getRejectedValue())</span><br><span class="line">                        .append(fieldError.getDefaultMessage());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                message.append(objectError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.PARAMETER_VALIDATION_ERROR.getErrorCode(),</span><br><span class="line">                String.format(ErrorCode.PARAMETER_VALIDATION_ERROR.getMessage(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul>
<li><strong>拦截器(Interceptor)</strong></li>
</ul>
<p>Java Web 中，在执行 Controller 方法前后对 Controller 请求进行拦截和处理。依赖于 web 框架，在 Spring 配置。在实现上基于 Java 的反射机制。</p>
<ul>
<li><strong>过滤器(Filter)</strong></li>
</ul>
<p>Java Web 中，在 request&#x2F;response 传入 Servlet 前，过滤信息或设置参数。依赖于 servlet 容器，在 web.xml 配置。在实现上基于函数回调。</p>
<blockquote>
<p>两者常用于修改字符编码、删除无用参数、登录校验等。Spring 框架中优先使用拦截器：功能接近、使用更加灵活。</p>
</blockquote>
<p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在配置中引入拦截器对象（单独编写拦截器类）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 导入拦截器对象，默认拦截全部</span></span><br><span class="line">    <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">myInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除配置</span></span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);               </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);                       </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 拦截配置</span></span><br><span class="line">    addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器类通过实现 HandlerInterceptor 接口或者继承 HandlerInterceptorAdapter 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 预处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 检查 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 重定向到登录页面</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 善后处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INTERCEPTOR POSTHANDLE CALLED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器类通过继承 Filter 类实现，直接添加注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>                                                                <span class="comment">// 作为组件，交给容器处理</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span>                                                     <span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/login/*&quot;,filterName = &quot;loginFilter&quot;)</span>           <span class="comment">// 设定过滤路径和名称</span></span><br><span class="line"><span class="meta">@Order(1)</span>                                                                 <span class="comment">// 设定优先级（值小会优先执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤器前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行内部逻辑</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">// 过滤器后执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>调用顺序</strong></p>
<p><img src="/filter.png" alt="filter"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Spring" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/11/06/Spring/" class="article-date">
  	<time datetime="2024-11-06T13:30:43.000Z" itemprop="datePublished">2024-11-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/11/06/Spring/">
        Spring
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是用于开发 Java 应用程序的开源框架，为解决企业应用开发的复杂性而创建。</p>
<ol>
<li>Spring 的基本设计思想是利用 IOC（依赖注入）和 AOP （面向切面）解耦应用组件，降低应用程序各组件之间的耦合度。</li>
<li>在这两者的基础上，Spring 逐渐衍生出了其他的高级功能：如 Security，JPA 等。</li>
</ol>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC 是 Spring 的子功能模块，专用于 Web 开发。</p>
<p>Spring MVC 基于 Servlet 实现，将 Web 应用中的数据业务、显示逻辑和控制逻辑进行分层设计。开发者可以直接调用 Spring MVC 框架中 Spring 解耦的组件，快速构建 Web 应用。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot 是用于简化创建 Spring 项目配置流程，快速构建 Spring 应用程序的辅助工具。Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能。但 在创建 Spring 项目时，Spring Boot 可以：</p>
<ol>
<li>自动添加 Maven 依赖，不需要在 pom.xml 中手动添加配置依赖。</li>
<li>不需要配置 XML 文件，将全部配置浓缩在一个 appliaction.yml 配置文件中。</li>
<li>自动创建启动类，代表着本工程项目和服务器的启动加载。</li>
<li>内嵌 Tomcat 、Jetty 等容器，无需手动部署 war 文件。</li>
</ol>
<hr>
<h2 id="Spring-Boot-配置"><a href="#Spring-Boot-配置" class="headerlink" title="Spring Boot 配置"></a>Spring Boot 配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在Spring Boot中，引入的所有包都是 starter 形式：</p>
<p>spring-boot-starter-web-services，针对 SOAP Web Services<br>spring-boot-starter-web，针对 Web 应用与网络接口<br>spring-boot-starter-jdbc，针对 JDBC<br>spring-boot-starter-data-jpa，基于 Hibernate 的持久层框架<br>spring-boot-starter-cache，针对缓存支持</p>
<h3 id="默认映射路径"><a href="#默认映射路径" class="headerlink" title="默认映射路径"></a>默认映射路径</h3><ul>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code></li>
<li><code>classpath:/public/</code></li>
</ul>
<p>优先级顺序：META-INF&#x2F;resources &gt; resources &gt; static &gt; public</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>位于 resources 文件夹下，支持以下两种格式。由 Spring Boot 自动加载。</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment">#访问前缀</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#数据库驱动</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jc.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="comment">#数据库用户名</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据库密码</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">wdh19970506</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="comment">#配置文件路径</span></span><br><span class="line"><span class="attr">mybatis_config_file</span>=<span class="string">mybatis-config.xml</span></span><br><span class="line"><span class="comment">#SQL语句配置路径</span></span><br><span class="line"><span class="attr">mapper_path</span>=<span class="string">/mapper/**.xml</span></span><br><span class="line"><span class="comment">#实体类所在包</span></span><br><span class="line"><span class="attr">type_alias_package</span>=<span class="string">com.example.demo.entity</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDBC 连接 Mysql5 驱动： com.mysql.jdbc.Driver</li>
<li>JDBC 连接 Mysql6 驱动： com.mysql.cj.jdbc.Driver , URL 必须要指定时区 serverTimezone ！</li>
</ul>
<p><strong>多重配置</strong></p>
<p>在 Spring Boot 中，我们往往需要配置多个不同的配置文件去适应不同的环境：</p>
<ul>
<li><code>application-dev.properties</code> 开发环境</li>
<li><code>application-test.properties</code> 测试环境</li>
<li><code>application-prod.properties</code> 生产环境</li>
</ul>
<p>只需要在程序默认配置文件 <code>application.properties</code> 中设置环境，就可以使用指定的配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p><code>@SpringBootApplication</code> 类：作为程序入口，在创建 Spring Boot 项目时自动创建。</p>
<p>等同于 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code> ，会自动完成配置并扫描路径下所有包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring 需要定义调度程序 servlet ，映射和其他支持配置。我们可以使用 web.xml 文件或 Initializer 类来完成此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.setConfigLocation(<span class="string">&quot;com.pingfangushi&quot;</span>);</span><br><span class="line">          container.addListener(<span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(context));</span><br><span class="line">          ServletRegistration.<span class="type">Dynamic</span> <span class="variable">dispatcher</span> <span class="operator">=</span> container</span><br><span class="line">          .addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要将 <code>@EnableWebMvc</code> 注释添加到 <code>@Configuration</code> 类，并定义一个视图解析器来解析从控制器返回的视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">InternalResourceViewResolver</span> <span class="variable">bean</span></span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalResourceViewResolver</span>();</span><br><span class="line">      bean.setViewClass(JstlView.class);</span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JDBC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/31/JDBC/" class="article-date">
  	<time datetime="2024-10-31T14:09:23.000Z" itemprop="datePublished">2024-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/31/JDBC/">
        JDBC
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><hr>
<h2 id="JDBC-简介"><a href="#JDBC-简介" class="headerlink" title="JDBC 简介"></a>JDBC 简介</h2><p>JDBC 是 Java EE 提供的数据库接口，负责连接 java 程序和后台数据库。安装数据库驱动程序后，开发者可以按照 JDBC 规范直接在 Java 程序上对数据库进行操作，由数据库厂商负责具体实现。</p>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><ol>
<li><p>下载 MySQL 驱动包，解压后得到 jar 库文件：<a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/connector/j/">http://dev.mysql.com/downloads/connector/j/</a></p>
</li>
<li><p>打开 IDE，在对应项目中 configure build path 导入 jar 库文件。</p>
</li>
</ol>
<hr>
<h2 id="JDBC-编程"><a href="#JDBC-编程" class="headerlink" title="JDBC 编程"></a>JDBC 编程</h2><p>JDBC 常用工具类位于 sql 包内，使用时需导入：<code>import java.sql.*</code> 。使用时可能 抛出 SQLException 异常。</p>
<h3 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h3><p>JDBC 首先要使用反射机制加载驱动类，并创建其对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);          <span class="comment">// MySQL 数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">// Oracle 数据库驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="连接数据库-Connection"><a href="#连接数据库-Connection" class="headerlink" title="连接数据库 Connection"></a>连接数据库 Connection</h3><p>JDBC 由 Connection 类负责连接数据库，参数中输入数据库 URL、账号、密码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接本地 RUNOOB 数据库，需设置时区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;            <span class="comment">// 数据库账号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;          <span class="comment">// 数据库密码</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(DB_URL,USER,PASS);    <span class="comment">// 建立连接</span></span><br><span class="line">conn.close();                                                       <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></figure>

<h3 id="执行语句-Statement"><a href="#执行语句-Statement" class="headerlink" title="执行语句 Statement"></a>执行语句 Statement</h3><p>JDBC 由 Statement 类负责发送 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> = conn.createStatement();         <span class="comment">// 创建 Statement 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// executeQuery 执行查询操作，返回 ResultSet 结果集</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM websites&quot;</span>); </span><br><span class="line"><span class="comment">// executeUpdate 执行更新操作，返回 int 数据表示受影响行数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stmt.executeUpdate(<span class="string">&quot;DELETE * FROM websites&quot;</span>); </span><br><span class="line">     </span><br><span class="line">stmt.close();                                      <span class="comment">// 关闭 Statement 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="返回查询结果-ResultSet"><a href="#返回查询结果-ResultSet" class="headerlink" title="返回查询结果 ResultSet"></a>返回查询结果 ResultSet</h3><p>JDBC 由 ResultSet 类返回 select 语句执行结果，读取 executeQuery 方法返回的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);             <span class="comment">// 获取返回结果</span></span><br><span class="line">               </span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;                                  <span class="comment">// 输出返回结果</span></span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JDBC-进阶"><a href="#JDBC-进阶" class="headerlink" title="JDBC 进阶"></a>JDBC 进阶</h2><h3 id="预编译-PreparedStatement"><a href="#预编译-PreparedStatement" class="headerlink" title="预编译 PreparedStatement"></a>预编译 PreparedStatement</h3><p>PreparedStatement 类继承自 Statement 类，在 JDBC 开发中用来取代前者。有以下两个优势：</p>
<ol>
<li>可对 SQL 语句进行预编译，可以灵活地修改 SQL 语句，提高开发效率。</li>
<li>把用户输入单引号转义，防止恶意注入，保护数据库安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.preparedStatement(sql);   <span class="comment">// 创建对象并预编译</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>, <span class="number">755</span>);                                          <span class="comment">// 在第一个占位符(?)位置插入数字</span></span><br><span class="line">stmt.setString(<span class="number">2</span>, <span class="string">&quot;MrJoker&quot;</span>);                                 <span class="comment">// 在第二个占位符(?)位置插入字符串</span></span><br><span class="line">stmt.executeUpdate();                                         <span class="comment">// 更新并执行</span></span><br></pre></td></tr></table></figure>

<h3 id="批处理-executeBath"><a href="#批处理-executeBath" class="headerlink" title="批处理 executeBath"></a>批处理 executeBath</h3><p>PreparedStatement 类可以通过 executeBath 方法批量处理 SQL 语句，进一步提高效率。其返回值为一个 int[] 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    stmt.setInt(<span class="number">1</span>, i);</span><br><span class="line">    stmt.setString(<span class="number">2</span>, (i + <span class="string">&quot;号士兵&quot;</span>));</span><br><span class="line">    stmt.addBatch();                                           <span class="comment">// 语句添加到批处理序列中</span></span><br><span class="line">&#125;</span><br><span class="line">preparedStatement.executeBatch();                              <span class="comment">// 语句发送给数据库批量处理</span></span><br><span class="line">preparedStatement.clearBatch();                                <span class="comment">// 清空批处理序列</span></span><br></pre></td></tr></table></figure>


<h3 id="大文本和二进制数据"><a href="#大文本和二进制数据" class="headerlink" title="大文本和二进制数据"></a>大文本和二进制数据</h3><ul>
<li><p>clob 用于存储大文本</p>
</li>
<li><p>blob用于存储二进制数据</p>
</li>
</ul>
<hr>
<h2 id="JDBC-示例"><a href="#JDBC-示例" class="headerlink" title="JDBC 示例"></a>JDBC 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于 JDK 1.8 以后版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> useMethod（）&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;                  </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;                    </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);                                </span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);    </span><br><span class="line">            stmt = conn.preparedStatement(<span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>);  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();        </span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));   </span><br><span class="line">            &#125;</span><br><span class="line">            rs.close(); </span><br><span class="line">            stmt.close(); </span><br><span class="line">            conn.close();                    </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;         <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;                                                 </span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                <span class="keyword">if</span>(stmt != <span class="literal">null</span>) stmt.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;&#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-IO流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/IO%E6%B5%81/" class="article-date">
  	<time datetime="2024-10-30T15:49:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/IO%E6%B5%81/">
        IO流
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO流"><a href="#IO流" class="headerlink" title="#IO流"></a>#IO流</h2><p>##总览</p>
<p>流的分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>分类1</th>
<th>分类2</th>
</tr>
</thead>
<tbody><tr>
<td>单位</td>
<td>字节流</td>
<td>字符流</td>
</tr>
<tr>
<td>流向</td>
<td>输入流</td>
<td>输出流</td>
</tr>
<tr>
<td>功能</td>
<td>节点流</td>
<td>处理流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>流名称</th>
<th>字节输入</th>
<th>字节输出</th>
<th>字符输入</th>
<th>字符输出</th>
</tr>
</thead>
<tbody><tr>
<td>4大基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>文件流</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td>-</td>
<td>-</td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>System</td>
<td>System.in</td>
<td>System.out</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>打印流</td>
<td>-</td>
<td>PrintStream</td>
<td>-</td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>缓存流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>数据流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong>内存流</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>随机访问流</td>
<td>-</td>
<td>RandomAccessFile</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>##四大抽象类</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><blockquote>
<p>说明：继承自InputStream的流都是用于向程序中输入数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract int read()	//从输入流中读取数据的下一个字节, 返回读到的字节值.若遇到流的末尾,返回-1
public int read(byte[] b)	//从输入流中读取 b.length 个字节的数据并存储到缓冲区数组b中.返回的是实际读到的字节总数
public int read(byte[] b, int off, int len)	//读取 len 个字节的数据,并从数组b的off位置开始写入到这个数组中
public void close()	//关闭此输入流并释放与此流关联的所有系统资源
public int available()	//返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数
public long skip(long n)	//跳过和丢弃此输入流中数据的 n 个字节，返回实现路过的字节数。
</code></pre>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><blockquote>
<p>说明：继承自OutputStream的流是程序用于向外输出数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract void write(int b)	//将指定的字节写入此输出流
public void write(byte[] b)	//将 b.length 个字节从指定的 byte 数组写入此输出流
public void write(byte[] b, int off, int len)	//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流
public void flush()	//刷新此输出流并强制写出所有缓冲的输出字节
pulbic void close()	//关闭此输出流并释放与此流有关的所有系统资源
</code></pre>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><blockquote>
<p>说明：继承自Reader的流都是用于向程序中输入数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public int read()	//读取单个字符的编码，返回作为整数读取的字符，如果已到达流的末尾返回-1
public int read(char[] cbuf)		//将字符读入数组，返回读取的字符数
public abstract int read(char[] cbuf, int off, int len)	//读取 len 个字符的数据，并从数组cbuf的off位置开始写入到这个数组中
public abstract void close()	//关闭该流并释放与之关联的所有资源
public long skip(long n) 	//跳过n个字符
int available() 	//还可以有多少能读到的字节数
</code></pre>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><blockquote>
<p>说明：继承自Writer的流是程序用于向外输出数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public void write(int c)		//写入单个字符
public void write(char[] cbuf)	//写入字符数组
public abstract void write(char[] cbuf, int off, int len)	//写入字符数组的某一部分
public void write(String str)	//写入字符串
public void write(String str, int off, int len)	//写字符串的某一部分
public abstract void close()	//关闭此流，但要先刷新它
public abstract void flush()	//刷新该流的缓冲，将缓冲的数据全写到目的地
</code></pre>
<hr>
<p>##节点流<br>###文件流</p>
<blockquote>
<p>说明：文件流主要用来操作文件</p>
</blockquote>
<ul>
<li><p><strong>FileInputStream</strong>:继承自InputStream</p>
</li>
<li><p><strong>FileOutputStream</strong>继承自OutputStream<br>FileOutputStream(String name, boolean append)  指定文件名和是否以追回方式写入</p>
</li>
<li><p><strong>FileReader</strong>继承自Reader<br>核心方法:</p>
<pre><code>1、构造方法
    FileReader(File file)
    FileReader(String fileName)
2、成员方法
    int read()	//每次读取一个字符，末尾-1返回值就是读入的内容
    int read(char[] cbuf)	//每次读取一组字符，最多读数组长度个，末尾-1返回值实际读取的个数
    int read(char[] cbuf,int off, int len)	//每次读取一组字符，最多len个，数据存入数组从off开始，末尾-1返回值实际读取的个数
    void close()
</code></pre>
</li>
<li><p><strong>FileWriter</strong>继承自Writer<br>核心方法:</p>
<pre><code>1、构造方法
    FileWriter(File file)
    FileWriter(File file,  boolean append)
    FileWriter(String fileName)
    FileWriter(String fileName, boolean append)	//构造方法来指定是否使用追加模式
2、成员方法
    void write(int c) 
    void write(char[] cbuf,int off, int len)
    void write(String str, int off,  int len)
    void flush()
    void close()
</code></pre>
</li>
</ul>
<p>###内存流</p>
<blockquote>
<p>说明：内存流主要用来操作内存，输入和输出可以从文件中来，也可以将设置在内存之上（内存：相当于长度可变的字节数组）</p>
</blockquote>
<p>分类：<br><strong>ByteArrayInputStream</strong>类：主要完成将内容从内存读入程序之中</p>
<pre><code>数据&lt;&lt;&lt;---------ByteArrayInputStream&lt;&lt;&lt;---------内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayInputStream（byte[] b）
ByteArrayInputStream(byte[] b,int off,int len)
</code></pre>
<p>常用方法：</p>
<pre><code>read()
skip()
available()
</code></pre>
<p><strong>ByteArrayOutputStream</strong>类：主要是将数据写入到内存中</p>
<pre><code>数据---------&gt;&gt;&gt;ByteArrayOutputStream---------&gt;&gt;&gt;内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayOutputStream（）
ByteArrayOutputStream（int size） ：指定缓冲区大小（byte）
</code></pre>
<p>常用方法：</p>
<pre><code>byte[] toByteArray():将内存流转换为字节数组
toString（）
write（int）
write（byte[] bytes）
write（byte[] bytes ，int off，int len） 
writeTo（OutputStream）
</code></pre>
<p><strong>注意：内存流不需要关闭</strong></p>
<p>##处理流(过滤流)<br>###缓冲流</p>
<blockquote>
<p>说明：缓冲流是处理流的一种,建立在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，还增加了一些新的方法</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>1、对于缓冲输出流，写出的数据会先缓存在内存缓冲区中，关闭此流前要用flush()方法将缓存区的数据立刻写出</li>
<li>2、关闭过滤流时，会自动关闭过滤流所包装的所有底层流</li>
</ul>
<p><strong>BufferedInputStream</strong> 可以对任何的InputStream流进行包装</p>
<p><strong>BufferedOutputStream</strong> 可以对任何的OutputStream流进行包装</p>
<p><strong>BufferedReader</strong> 可以对任何的Reader流进行包装</p>
<blockquote>
<p>新增了readLine()方法用于一次读取一行字符串(以‘\r’或‘\n’认为一行结束)返回一行 如果没有返回null</p>
</blockquote>
<p><strong>BufferedWriter</strong> 可以对任何的Writer流进行包装</p>
<blockquote>
<p>新增了newLine()方法，用于跨平台的写入换行符</p>
</blockquote>
<p>###Object流</p>
<blockquote>
<p>说明：JDK提供的ObjectOutputStream和ObjectInputStream类是用于存储和读取基本数据类型或对象的过滤流</p>
</blockquote>
<p><strong>序列化</strong>：用ObjectOutputStream类保存基本数据类型或对象的机制叫序列化</p>
<p><strong>反序列化</strong>：用ObjectInputStream类读取基本数据类型或对象的机制叫反序列化</p>
<p><strong>Serializable接口</strong></p>
<pre><code>作用：能被序列化的对象所对应的类必须实现java.io.Serializable这个标识性接口
注意：实现此接口的类，需要提供一个静态long类型的常量serialVersionUID，保证序列化与反序列化的一致性
</code></pre>
<p><strong>构造方法</strong>:</p>
<pre><code>public ObjectOutputStream(OutputStream out)
public ObjectInputStream(InputStream in)
</code></pre>
<p><strong>transient关键字</strong>:</p>
<pre><code>transient关键字修饰成员变量时，表示这个成员变量是不需要序列化的
static修饰的成员变量也不会被序列化
</code></pre>
<p>###打印流</p>
<blockquote>
<p>说明：向控制台输出数据</p>
</blockquote>
<p>PrintStream类：字节输出流</p>
<p>PrintWriter类：字符输出流</p>
<p>打印流示例（<strong>注意：write写入的是字节</strong>）：</p>
<pre><code>PrintStream ps = new PrintStream(&quot;src/print.txt&quot;);
    ps.write(355);// 字节 00000000 00000000 00000001 01100011
                    // 舍弃前三位---》01100011--》c
    ps.println(355);
    ps.flush();
    ps.close();
</code></pre>
<p><strong>注意</strong></p>
<pre><code>System.out就是PrintStream的一个实例
PrintStream和PrintWriter的输出操作不会抛出异常
</code></pre>
<p>构造方法:</p>
<pre><code>PrintStream(OutputStream out)
PrintStream(OutputStream out, boolean autoFlush)
PrintWriter(Writer out)
PrintWriter(Writer out, boolean autoFlush)
PrintWriter(OutputStream out)
PrintWriter(OutputStream out, boolean autoFlush)
</code></pre>
<p>###转换流</p>
<blockquote>
<p>作用：转换流用于在字节流和字符流之间转换。</p>
</blockquote>
<p>分类：</p>
<ul>
<li><p><strong>InputStreamReader</strong>类</p>
<pre><code>1）是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象
2）InputStreamReader需要和InputStream“套接”，它可以将字节流中读入的字节解码成字符
</code></pre>
</li>
<li><p><strong>OutputStreamWriter</strong>类</p>
<pre><code>1）是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流的输出对象
2）OutputStreamWriter需要和OutputStream“套接”，它可以将要写入字节流的字符编码成字节
</code></pre>
</li>
</ul>
<p>转换过程：</p>
<ul>
<li><p>写入数据</p>
<pre><code>程序---&gt;&gt;字符数据---&gt;&gt;字符流---&gt;&gt;OutputStreamWriter---&gt;&gt;字节流---&gt;&gt;文件
</code></pre>
</li>
<li><p>读出数据</p>
<pre><code>  程序&lt;&lt;---字符数据&lt;&lt;---字符流&lt;&lt;----InputStreamReader&lt;&lt;---字节流&lt;&lt;---文件
</code></pre>
</li>
</ul>
<p>###数据流</p>
<p><strong>DataInputStream</strong>类</p>
<blockquote>
<p>作用：读取简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>readInt() 读取一个基本数据类型数据
readInt() 读取一个基本数据类型数据
</code></pre>
<p><strong>DataOutputStream</strong>类</p>
<blockquote>
<p>作用：写出简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>writeInt(int i)
writeUTF(String s) 写入UTF-8编码的字符串
</code></pre>
<p>##RandomAccessFile类(随机访问文件)</p>
<blockquote>
<p>作用：完成随机读取功能，可以读取指定位置的内容</p>
</blockquote>
<p>构造方法：</p>
<pre><code>public RandomAccessFile(File file,  String mode) 
public RandomAccessFile(File file,  String mode) 
</code></pre>
<p>文件的打开模式</p>
<pre><code>“r” 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  
“rw” 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。  
</code></pre>
<p>常用方法:</p>
<pre><code>getFilePointer():返回子文件中当前的偏移量	
seek(long l):设置到此文件开头测量到的文件的偏移量 在该位置的下一个发生读、写操作
</code></pre>
<p>注意：</p>
<pre><code>RandomAccessFile raf = new RandomAccessFile(&quot;src/per.txt&quot;, &quot;rw&quot;);
//这里遍历的时候需注意要用getFilePointer()读取光标的位置
for (int i = 0; i &lt; raf.length(); i = (int) raf.getFilePointer()) &#123;
    //do ...			
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  	<time datetime="2024-10-30T15:43:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
        异常处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><hr>
<h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><p>Java 程序中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
<p>java 程序中所有的异常都继承自 Throwable 类，Throwable 类有两个子类 Error 类和 Exception 类：</p>
<ul>
<li><p><strong>Error 类</strong>：【错误】表示 java 程序在运行时产生的无法处理的故障（如堆栈溢出），错误出现时会导致程序无法正常执行并强制退出。</p>
</li>
<li><p><strong>Exception 类</strong>：【异常】表示 java 程序中产生的可以被处理的故障，异常出现时可以由程序进行处理。</p>
</li>
</ul>
<h3 id="RuntimeException-类"><a href="#RuntimeException-类" class="headerlink" title="RuntimeException 类"></a>RuntimeException 类</h3><p>【运行时异常】 Exception 类的子类。</p>
<p>表示 java 程序运行状态中发生的异常，在编译时无法被检测。在 java 程序运行时会由系统自动抛出，允许应用程序不进行处理。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术异常，以零做除数</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundException</td>
<td>数组越界异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>空指针异常，对象不存在</td>
</tr>
</tbody></table>
<h3 id="Checked-Exception-类"><a href="#Checked-Exception-类" class="headerlink" title="Checked Exception 类"></a>Checked Exception 类</h3><p>【可检查异常】Exception 类除 RuntimeException 以外其他子类的统称。</p>
<p>表示 java 程序编译时检测到的异常。出现时必须在程序中进行捕获或抛出，否则编译不会通过。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>IOException</td>
<td>IO 异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>找不到文件异常，继承自 IO 异常</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类异常</td>
</tr>
</tbody></table>
<hr>
<h2 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h2><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>状态信息</strong></p>
<p>Throwable &#x2F; Exception 类是有状态的（因此 Throwable 是接口而不能是类），记录了四个信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object backtrace;                          <span class="comment">// 栈的回溯点</span></span><br><span class="line"><span class="keyword">private</span> String detailMessage;                                <span class="comment">// 异常的信息：在创建异常时备注</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="built_in">this</span>;                              <span class="comment">// 异常的原因：导致该异常的异常，默认为自身</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;   <span class="comment">// 异常的发生顺序：以栈的形式存储</span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p>Throwable &#x2F; Exception 类含有四个构造方法，在创建时可以记录异常信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();                           <span class="comment">// 默认</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>);                  <span class="comment">// 记录异常信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);                          <span class="comment">// 记录异常原因</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>, e);               <span class="comment">// 记录详细信息和异常原因</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<p>Throwable &#x2F; Exception 类定义了多种常用方法用于获取异常数据，常用的有：</p>
<ul>
<li>getMessage 方法：获取异常的信息。</li>
<li>getStackTrace 方法：获取的异常发生顺序。</li>
<li>printStackTrace 方法：获取异常的发生顺序并打印（开发和调试阶段用来显示异常信息，帮助开发者找出错误）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    e.printStacTrace();                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>我们也可以通过继承并重写 Exception &#x2F; RuntimeException 类的方式，自定义异常类并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义异常，重写方法可任选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message,cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常转译"><a href="#异常转译" class="headerlink" title="异常转译"></a>异常转译</h3><p>在项目开发过程中，当 Sevice&#x2F;DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。程序可以捕获原始异常，然后再抛出一个新的业务异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;SQL Error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 throw</h3><p>当方法执行出现问题时，方法就会创建异常对象并抛出。开发者可以在程序中自行抛出异常；JVM 在执行程序时发现问题也会自动抛出异常。</p>
<ul>
<li><p><strong>throw 语句</strong>：开发者自行创建异常对象并抛出，等待程序进行异常处理。</p>
</li>
<li><p><strong>throws 语句</strong>：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;       </span><br><span class="line">    <span class="comment">// 把方法中的抛出异常交给上层处理     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> IndexOutOfBoundsException, IOException&#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 用户自定义异常并抛出</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 虚拟机自动发现异常也会抛出，必须出现在 try 代码块中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(txt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-catch"><a href="#捕获异常-catch" class="headerlink" title="捕获异常 catch"></a>捕获异常 catch</h3><p>当方法执行抛出异常时，必须由专门的代码块对异常进行处理。</p>
<ul>
<li><p><strong>try 语句</strong>：可能出现异常的代码块。</p>
</li>
<li><p><strong>catch 语句</strong>：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。</p>
</li>
<li><p><strong>finally 语句</strong>：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><p>如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理。但必须在方法中声明 throws。</p>
</li>
<li><p>try&#x2F;catch 代码中的 return 语句会在执行完 finally 后再返回，但 finally 中对返回变量的改变不会影响最终的返回结果。</p>
</li>
<li><p>finally 代码中应避免含有 return 语句或抛出异常，否则只会执行 finally 中的 return 语句，且不会向上级抛出异常。</p>
</li>
</ol>
<p><em>Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;               </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<!--

**异常处理类**

在 Spring Boot 中，所有异常统一由专门的异常处理类`@ControllerAdvice`处理。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制器异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorHandler.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入参数校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NotValidExceptionHandler</span><span class="params">(HttpServletRequest req, MethodArgumentNotValidException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rfc4918 - 11.2. 422: Unprocessable Entity          </span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> MiscUtil.getValidateError(bindingResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.UNPROCESSABLE_ENTITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//404异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NoHandlerFoundExceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">404</span>, <span class="string">&quot;页面不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他默认异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">defaultHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-概念区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/" class="article-date">
  	<time datetime="2024-10-30T13:05:40.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/">
        概念区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###关键概念区别</p>
<p>####抽象类与接口</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>abstract  class</td>
<td>interface</td>
</tr>
<tr>
<td>概念</td>
<td>不能实例化的类，可能包含抽象方法</td>
<td>抽象方法和静态常量的集合</td>
</tr>
<tr>
<td>组成</td>
<td>抽象方法、普通方法、静态方法、变量、常量、静态变量、构造方法</td>
<td>抽象方法、静态常量</td>
</tr>
<tr>
<td>子类</td>
<td>子类继承抽象类</td>
<td>实现类实现接口</td>
</tr>
<tr>
<td>继承或实现关键字</td>
<td>extends</td>
<td>implements</td>
</tr>
<tr>
<td>局限性</td>
<td>单继承，可以多层继承</td>
<td>没有限制</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可以实现接口</td>
<td>接口不能继承抽象类</td>
</tr>
<tr>
<td>应用类</td>
<td>父类强制子类完成某些特定的功能，当然父类中也包含了共同的代码</td>
<td>约定、规范。 方法的描述，子类必须完成所有的方法</td>
</tr>
</tbody></table>
<p>####重写与重载</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重写</th>
<th>重载</th>
</tr>
</thead>
<tbody><tr>
<td>关键词</td>
<td>override</td>
<td>overload</td>
</tr>
<tr>
<td>概念</td>
<td>子类重写父类的方法</td>
<td>一个方法的多种展现形式</td>
</tr>
<tr>
<td>环境</td>
<td>子类和父类</td>
<td>一个类中</td>
</tr>
<tr>
<td>方法名</td>
<td>相同</td>
<td>相同</td>
</tr>
<tr>
<td>参数列表</td>
<td>相同</td>
<td>必须不同</td>
</tr>
<tr>
<td>返回值</td>
<td>相同</td>
<td>没有要求</td>
</tr>
<tr>
<td>访问权限</td>
<td>子类不能比父类更加严格</td>
<td>没有要求</td>
</tr>
<tr>
<td>异常</td>
<td>子类不能抛出比父类大的异常</td>
<td>没有要求</td>
</tr>
</tbody></table>
<hr>
<p>####this与super<br>总结：<strong>this是当前对象在堆空间的引用地址,super是当前对象的父类特征的引用</strong></p>
<p>super 只是记录对象内部的父类的特征(属性和方法)的一个引用</p>
<blockquote>
<p>这儿<strong>super不是指向父类对象的引用地址</strong>,new出来的才在堆里面分配空间有引用地址,这儿没有去new一个父类对象,只是执行了父类的构造函数将父类的特征生成了,但是属于New出来的那个子类对象的</p>
</blockquote>
<p>实践一下,你可以写</p>
<pre><code>public FatherClass getThis() 
&#123; 
return this; 
&#125; 
</code></pre>
<p>编译通过,没有任何问题<br>但是你写</p>
<pre><code>public FatherClass getSuper() 
&#123; 
return super; 
&#125; 
</code></pre>
<p>嘿嘿,编译出错! 为什么啦？</p>
<ul>
<li>因为super并不是一个堆空间里面的一个对象的引用地址,而this才是堆空间里面的一个对象的引用地址</li>
<li>super只能在对象内部使用,而this可以在对象内部使用也可以返回出对象外.</li>
<li>super是死的,编译的时候就定死了super的指向了,而this是活的,在运行时候决定其指向.</li>
</ul>
<p>解释一下:</p>
<blockquote>
<p>子类实例化对象,并没有去实例化他的父类对象,也就是说,那个子类对象里面并没有一个父类对象,那你说没有父类对象,为什么子类构造函数要执行父类的构造函数啦,那是因为需要创建父类的特征赋予子类,但是是由子类所有,而super就是用来区别是是否是父类对象的特征的.<br>重写父类方法属性,就是再创建了一个子类的特征,当你用this的时候,就覆盖了父类的特征了,但是父类特征还在那儿,用super就能访问到,但是只能在对象的内部使用.对象外面就只能看到覆盖了父类特征的子类特征了.</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td>this.属性名。只能访问当前对象所拥有的属性(包括继承来的属性，如果继承的属性名和子类对象相同，若不指定则调用子类的，调用父类的需要显示指定：super.属性名)</td>
<td>super.属性名。可以访问父类非私有的属性</td>
</tr>
<tr>
<td>访问方法</td>
<td>与访问属性类似</td>
<td>与访问属性类似</td>
</tr>
<tr>
<td>调用构造器</td>
<td>this(有参或无参)调用本类中有参或无参的构造函数，必须放在构造函数的第一句</td>
<td>super(有参还是无参)调用父类的有参或是无参的构造方法，必须放在构造方法的第一行（注意：**在同一个构造函数里不能同时出现this()和super()**）</td>
</tr>
<tr>
<td>指代</td>
<td>this是当前对象在堆空间的引用地址</td>
<td>super是当前对象的父类特征的引用</td>
</tr>
<tr>
<td>作为参数</td>
<td>this可以作为参数，它代表了当前对象的引用</td>
<td>super不可以</td>
</tr>
<tr>
<td>使用环境</td>
<td>不可以在static环境中使用</td>
<td>不可以在static环境中使用</td>
</tr>
</tbody></table>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  	<time datetime="2024-10-30T13:01:29.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
        面向对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><hr>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li><p><strong>面向过程</strong>：根据解决问题的过程，直接设计系统。如 C 语言。</p>
</li>
<li><p><strong>面向对象</strong>：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。</p>
<ul>
<li><p>特性：封装、继承、多态。</p>
</li>
<li><p>优点：使系统更加灵活，易维护、易复用、易扩展。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。</p>
<p>成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  </span><br><span class="line">        inner.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">myrifle</span> <span class="operator">=</span> f.getRifle();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">getRifle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">Gun</span> &#123;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rifle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。</p>
<p>最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类或接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123; </span><br><span class="line">            <span class="comment">// 定义匿名内部类并直接使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 无需外部对象，直接创建内部类</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类继承父类后，无需定义也可使用父类定义好的 public&#x2F;protected 方法和属性。也可以进行扩展和方法的重写。</p>
<ul>
<li>父类的<strong>属性值</strong>不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。</li>
<li>父类的 <strong>static 方法</strong>不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。</li>
<li>父类的<strong>构造方法</strong>不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trunk</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123; </span><br><span class="line">    <span class="comment">// 重定义属性（未公开无法继承）</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;this is a trunk&quot;</span>;</span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="type">int</span> goods;</span><br><span class="line">    <span class="comment">// 扩展方法              </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.goods += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trunk</span><span class="params">(String brand)</span>&#123;    </span><br><span class="line">        <span class="built_in">super</span>(brand);        </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.go(loc);                            </span><br><span class="line">        System.out.print(<span class="string">&quot; with&quot;</span> + goods + <span class="string">&quot;goods&quot;</span>); </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。</em></p>
<hr>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Charge</span> <span class="keyword">extends</span> <span class="title class_">Move</span>, Fight&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h3><ul>
<li><strong>重载</strong>(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。</li>
<li><strong>重写</strong>(override)：子类定义完全相同的方法覆盖父类。</li>
</ul>
<p>重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。</p>
<p><code>Car mycar = new Trunk(&quot;Benz&quot;);</code></p>
<p>但不允许子类引用指向父类对象。</p>
<p><del><code>Trunk mycar = new Car(&quot;Benz&quot;);</code></del></p>
<p>如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。</p>
<p><code>Trunk newCar = (Trunk)mycar; </code></p>
<h3 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h3><ul>
<li><p><strong>调用普通方法</strong></p>
<p>子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。</p>
</li>
<li><p><strong>调用 static &#x2F; private &#x2F; final 以及构造方法</strong></p>
<p>特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。</p>
</li>
<li><p><strong>调用成员变量</strong></p>
<p>父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trunk</span>(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line"></span><br><span class="line">myCar.go(<span class="string">&quot;London&quot;</span>);                    <span class="comment">// (trunk) go to London with 0 goods</span></span><br><span class="line">myCar.showNum();                       <span class="comment">// (car) 1</span></span><br><span class="line">System.out.print(myCar.description);   <span class="comment">// (car) this is a car</span></span><br><span class="line"></span><br><span class="line"><span class="type">Trunk</span> <span class="variable">newCar</span> <span class="operator">=</span> (Trunk)mycar;           <span class="comment">// 强制类型转换</span></span><br><span class="line">System.out.print(newCar.description);  <span class="comment">// (trunk) this is a trunk</span></span><br></pre></td></tr></table></figure>


<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性。</li>
</ul>
<p>通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。</p>
<p>但是在性能上会有较大的损耗。</p>
<p><em>尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。</em></p>
<h4 id="反射机制运用"><a href="#反射机制运用" class="headerlink" title="反射机制运用"></a>反射机制运用</h4><p>类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。</p>
<ul>
<li><strong>Class 类</strong>：类</li>
<li><strong>Constructor 类</strong>：类的构造方法</li>
<li><strong>Field 类</strong>：类的属性</li>
<li><strong>Method 类</strong>：类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 对象 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种方式 返回对象的类 【已有对象，获取类无意义】</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第三种方式 返回路径下的类 【常用】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 信息 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getName());   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getConstructors();</span><br><span class="line">        <span class="comment">// 获取类的全部构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取类的指定构造方法（参数）</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getConstructor(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getFields(); </span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取类的指定属性（属性名）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有方法</span></span><br><span class="line">        Method[] methodArray = stuClass.getMethods(); </span><br><span class="line">        <span class="comment">// 获取类的全部方法                </span></span><br><span class="line">        Method[] methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取类的指定方法（方法名+形参类型）                  </span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;main&quot;</span>, String.class);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 在对象中使用 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();   <span class="comment">// 调用公有无参构造方法创建对象</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;X-man&quot;</span>);              <span class="comment">// 为对象的公有属性赋值</span></span><br><span class="line">        m.invoke(obj, <span class="string">&quot;X-man&quot;</span>);           <span class="comment">// 调用对象的公有方法</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><a href="/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?id=%E6%B3%9B%E5%9E%8B">泛型</a>在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：</p>
<p><em>在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	</span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); </span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/hello-world/" class="article-date">
  	<time datetime="2024-10-30T11:51:07.500Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 Camellia
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>