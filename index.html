<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Camellia</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Camellia">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Camellia">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Camellia">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Camellia" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="[object Object]" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Camellia</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=32717172&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/ymbyh/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="[object Object]" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-IO流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/IO%E6%B5%81/" class="article-date">
  	<time datetime="2024-10-30T15:49:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/IO%E6%B5%81/">
        IO流
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO流"><a href="#IO流" class="headerlink" title="#IO流"></a>#IO流</h2><p>##总览</p>
<p>流的分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>分类1</th>
<th>分类2</th>
</tr>
</thead>
<tbody><tr>
<td>单位</td>
<td>字节流</td>
<td>字符流</td>
</tr>
<tr>
<td>流向</td>
<td>输入流</td>
<td>输出流</td>
</tr>
<tr>
<td>功能</td>
<td>节点流</td>
<td>处理流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>流名称</th>
<th>字节输入</th>
<th>字节输出</th>
<th>字符输入</th>
<th>字符输出</th>
</tr>
</thead>
<tbody><tr>
<td>4大基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>文件流</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td>-</td>
<td>-</td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>System</td>
<td>System.in</td>
<td>System.out</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>打印流</td>
<td>-</td>
<td>PrintStream</td>
<td>-</td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>缓存流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>数据流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong>内存流</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>随机访问流</td>
<td>-</td>
<td>RandomAccessFile</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>##四大抽象类</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><blockquote>
<p>说明：继承自InputStream的流都是用于向程序中输入数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract int read()	//从输入流中读取数据的下一个字节, 返回读到的字节值.若遇到流的末尾,返回-1
public int read(byte[] b)	//从输入流中读取 b.length 个字节的数据并存储到缓冲区数组b中.返回的是实际读到的字节总数
public int read(byte[] b, int off, int len)	//读取 len 个字节的数据,并从数组b的off位置开始写入到这个数组中
public void close()	//关闭此输入流并释放与此流关联的所有系统资源
public int available()	//返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数
public long skip(long n)	//跳过和丢弃此输入流中数据的 n 个字节，返回实现路过的字节数。
</code></pre>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><blockquote>
<p>说明：继承自OutputStream的流是程序用于向外输出数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract void write(int b)	//将指定的字节写入此输出流
public void write(byte[] b)	//将 b.length 个字节从指定的 byte 数组写入此输出流
public void write(byte[] b, int off, int len)	//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流
public void flush()	//刷新此输出流并强制写出所有缓冲的输出字节
pulbic void close()	//关闭此输出流并释放与此流有关的所有系统资源
</code></pre>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><blockquote>
<p>说明：继承自Reader的流都是用于向程序中输入数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public int read()	//读取单个字符的编码，返回作为整数读取的字符，如果已到达流的末尾返回-1
public int read(char[] cbuf)		//将字符读入数组，返回读取的字符数
public abstract int read(char[] cbuf, int off, int len)	//读取 len 个字符的数据，并从数组cbuf的off位置开始写入到这个数组中
public abstract void close()	//关闭该流并释放与之关联的所有资源
public long skip(long n) 	//跳过n个字符
int available() 	//还可以有多少能读到的字节数
</code></pre>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><blockquote>
<p>说明：继承自Writer的流是程序用于向外输出数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public void write(int c)		//写入单个字符
public void write(char[] cbuf)	//写入字符数组
public abstract void write(char[] cbuf, int off, int len)	//写入字符数组的某一部分
public void write(String str)	//写入字符串
public void write(String str, int off, int len)	//写字符串的某一部分
public abstract void close()	//关闭此流，但要先刷新它
public abstract void flush()	//刷新该流的缓冲，将缓冲的数据全写到目的地
</code></pre>
<hr>
<p>##节点流<br>###文件流</p>
<blockquote>
<p>说明：文件流主要用来操作文件</p>
</blockquote>
<ul>
<li><p><strong>FileInputStream</strong>:继承自InputStream</p>
</li>
<li><p><strong>FileOutputStream</strong>继承自OutputStream<br>FileOutputStream(String name, boolean append)  指定文件名和是否以追回方式写入</p>
</li>
<li><p><strong>FileReader</strong>继承自Reader<br>核心方法:</p>
<pre><code>1、构造方法
    FileReader(File file)
    FileReader(String fileName)
2、成员方法
    int read()	//每次读取一个字符，末尾-1返回值就是读入的内容
    int read(char[] cbuf)	//每次读取一组字符，最多读数组长度个，末尾-1返回值实际读取的个数
    int read(char[] cbuf,int off, int len)	//每次读取一组字符，最多len个，数据存入数组从off开始，末尾-1返回值实际读取的个数
    void close()
</code></pre>
</li>
<li><p><strong>FileWriter</strong>继承自Writer<br>核心方法:</p>
<pre><code>1、构造方法
    FileWriter(File file)
    FileWriter(File file,  boolean append)
    FileWriter(String fileName)
    FileWriter(String fileName, boolean append)	//构造方法来指定是否使用追加模式
2、成员方法
    void write(int c) 
    void write(char[] cbuf,int off, int len)
    void write(String str, int off,  int len)
    void flush()
    void close()
</code></pre>
</li>
</ul>
<p>###内存流</p>
<blockquote>
<p>说明：内存流主要用来操作内存，输入和输出可以从文件中来，也可以将设置在内存之上（内存：相当于长度可变的字节数组）</p>
</blockquote>
<p>分类：<br><strong>ByteArrayInputStream</strong>类：主要完成将内容从内存读入程序之中</p>
<pre><code>数据&lt;&lt;&lt;---------ByteArrayInputStream&lt;&lt;&lt;---------内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayInputStream（byte[] b）
ByteArrayInputStream(byte[] b,int off,int len)
</code></pre>
<p>常用方法：</p>
<pre><code>read()
skip()
available()
</code></pre>
<p><strong>ByteArrayOutputStream</strong>类：主要是将数据写入到内存中</p>
<pre><code>数据---------&gt;&gt;&gt;ByteArrayOutputStream---------&gt;&gt;&gt;内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayOutputStream（）
ByteArrayOutputStream（int size） ：指定缓冲区大小（byte）
</code></pre>
<p>常用方法：</p>
<pre><code>byte[] toByteArray():将内存流转换为字节数组
toString（）
write（int）
write（byte[] bytes）
write（byte[] bytes ，int off，int len） 
writeTo（OutputStream）
</code></pre>
<p><strong>注意：内存流不需要关闭</strong></p>
<p>##处理流(过滤流)<br>###缓冲流</p>
<blockquote>
<p>说明：缓冲流是处理流的一种,建立在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，还增加了一些新的方法</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>1、对于缓冲输出流，写出的数据会先缓存在内存缓冲区中，关闭此流前要用flush()方法将缓存区的数据立刻写出</li>
<li>2、关闭过滤流时，会自动关闭过滤流所包装的所有底层流</li>
</ul>
<p><strong>BufferedInputStream</strong> 可以对任何的InputStream流进行包装</p>
<p><strong>BufferedOutputStream</strong> 可以对任何的OutputStream流进行包装</p>
<p><strong>BufferedReader</strong> 可以对任何的Reader流进行包装</p>
<blockquote>
<p>新增了readLine()方法用于一次读取一行字符串(以‘\r’或‘\n’认为一行结束)返回一行 如果没有返回null</p>
</blockquote>
<p><strong>BufferedWriter</strong> 可以对任何的Writer流进行包装</p>
<blockquote>
<p>新增了newLine()方法，用于跨平台的写入换行符</p>
</blockquote>
<p>###Object流</p>
<blockquote>
<p>说明：JDK提供的ObjectOutputStream和ObjectInputStream类是用于存储和读取基本数据类型或对象的过滤流</p>
</blockquote>
<p><strong>序列化</strong>：用ObjectOutputStream类保存基本数据类型或对象的机制叫序列化</p>
<p><strong>反序列化</strong>：用ObjectInputStream类读取基本数据类型或对象的机制叫反序列化</p>
<p><strong>Serializable接口</strong></p>
<pre><code>作用：能被序列化的对象所对应的类必须实现java.io.Serializable这个标识性接口
注意：实现此接口的类，需要提供一个静态long类型的常量serialVersionUID，保证序列化与反序列化的一致性
</code></pre>
<p><strong>构造方法</strong>:</p>
<pre><code>public ObjectOutputStream(OutputStream out)
public ObjectInputStream(InputStream in)
</code></pre>
<p><strong>transient关键字</strong>:</p>
<pre><code>transient关键字修饰成员变量时，表示这个成员变量是不需要序列化的
static修饰的成员变量也不会被序列化
</code></pre>
<p>###打印流</p>
<blockquote>
<p>说明：向控制台输出数据</p>
</blockquote>
<p>PrintStream类：字节输出流</p>
<p>PrintWriter类：字符输出流</p>
<p>打印流示例（<strong>注意：write写入的是字节</strong>）：</p>
<pre><code>PrintStream ps = new PrintStream(&quot;src/print.txt&quot;);
    ps.write(355);// 字节 00000000 00000000 00000001 01100011
                    // 舍弃前三位---》01100011--》c
    ps.println(355);
    ps.flush();
    ps.close();
</code></pre>
<p><strong>注意</strong></p>
<pre><code>System.out就是PrintStream的一个实例
PrintStream和PrintWriter的输出操作不会抛出异常
</code></pre>
<p>构造方法:</p>
<pre><code>PrintStream(OutputStream out)
PrintStream(OutputStream out, boolean autoFlush)
PrintWriter(Writer out)
PrintWriter(Writer out, boolean autoFlush)
PrintWriter(OutputStream out)
PrintWriter(OutputStream out, boolean autoFlush)
</code></pre>
<p>###转换流</p>
<blockquote>
<p>作用：转换流用于在字节流和字符流之间转换。</p>
</blockquote>
<p>分类：</p>
<ul>
<li><p><strong>InputStreamReader</strong>类</p>
<pre><code>1）是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象
2）InputStreamReader需要和InputStream“套接”，它可以将字节流中读入的字节解码成字符
</code></pre>
</li>
<li><p><strong>OutputStreamWriter</strong>类</p>
<pre><code>1）是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流的输出对象
2）OutputStreamWriter需要和OutputStream“套接”，它可以将要写入字节流的字符编码成字节
</code></pre>
</li>
</ul>
<p>转换过程：</p>
<ul>
<li><p>写入数据</p>
<pre><code>程序---&gt;&gt;字符数据---&gt;&gt;字符流---&gt;&gt;OutputStreamWriter---&gt;&gt;字节流---&gt;&gt;文件
</code></pre>
</li>
<li><p>读出数据</p>
<pre><code>  程序&lt;&lt;---字符数据&lt;&lt;---字符流&lt;&lt;----InputStreamReader&lt;&lt;---字节流&lt;&lt;---文件
</code></pre>
</li>
</ul>
<p>###数据流</p>
<p><strong>DataInputStream</strong>类</p>
<blockquote>
<p>作用：读取简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>readInt() 读取一个基本数据类型数据
readInt() 读取一个基本数据类型数据
</code></pre>
<p><strong>DataOutputStream</strong>类</p>
<blockquote>
<p>作用：写出简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>writeInt(int i)
writeUTF(String s) 写入UTF-8编码的字符串
</code></pre>
<p>##RandomAccessFile类(随机访问文件)</p>
<blockquote>
<p>作用：完成随机读取功能，可以读取指定位置的内容</p>
</blockquote>
<p>构造方法：</p>
<pre><code>public RandomAccessFile(File file,  String mode) 
public RandomAccessFile(File file,  String mode) 
</code></pre>
<p>文件的打开模式</p>
<pre><code>“r” 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  
“rw” 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。  
</code></pre>
<p>常用方法:</p>
<pre><code>getFilePointer():返回子文件中当前的偏移量	
seek(long l):设置到此文件开头测量到的文件的偏移量 在该位置的下一个发生读、写操作
</code></pre>
<p>注意：</p>
<pre><code>RandomAccessFile raf = new RandomAccessFile(&quot;src/per.txt&quot;, &quot;rw&quot;);
//这里遍历的时候需注意要用getFilePointer()读取光标的位置
for (int i = 0; i &lt; raf.length(); i = (int) raf.getFilePointer()) &#123;
    //do ...			
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  	<time datetime="2024-10-30T15:43:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
        异常处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><hr>
<h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><p>Java 程序中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
<p>java 程序中所有的异常都继承自 Throwable 类，Throwable 类有两个子类 Error 类和 Exception 类：</p>
<ul>
<li><p><strong>Error 类</strong>：【错误】表示 java 程序在运行时产生的无法处理的故障（如堆栈溢出），错误出现时会导致程序无法正常执行并强制退出。</p>
</li>
<li><p><strong>Exception 类</strong>：【异常】表示 java 程序中产生的可以被处理的故障，异常出现时可以由程序进行处理。</p>
</li>
</ul>
<p><img src="/exception.png" alt="Throwable"></p>
<h3 id="RuntimeException-类"><a href="#RuntimeException-类" class="headerlink" title="RuntimeException 类"></a>RuntimeException 类</h3><p>【运行时异常】 Exception 类的子类。</p>
<p>表示 java 程序运行状态中发生的异常，在编译时无法被检测。在 java 程序运行时会由系统自动抛出，允许应用程序不进行处理。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术异常，以零做除数</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundException</td>
<td>数组越界异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>空指针异常，对象不存在</td>
</tr>
</tbody></table>
<h3 id="Checked-Exception-类"><a href="#Checked-Exception-类" class="headerlink" title="Checked Exception 类"></a>Checked Exception 类</h3><p>【可检查异常】Exception 类除 RuntimeException 以外其他子类的统称。</p>
<p>表示 java 程序编译时检测到的异常。出现时必须在程序中进行捕获或抛出，否则编译不会通过。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>IOException</td>
<td>IO 异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>找不到文件异常，继承自 IO 异常</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类异常</td>
</tr>
</tbody></table>
<hr>
<h2 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h2><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>状态信息</strong></p>
<p>Throwable &#x2F; Exception 类是有状态的（因此 Throwable 是接口而不能是类），记录了四个信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object backtrace;                          <span class="comment">// 栈的回溯点</span></span><br><span class="line"><span class="keyword">private</span> String detailMessage;                                <span class="comment">// 异常的信息：在创建异常时备注</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="built_in">this</span>;                              <span class="comment">// 异常的原因：导致该异常的异常，默认为自身</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;   <span class="comment">// 异常的发生顺序：以栈的形式存储</span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p>Throwable &#x2F; Exception 类含有四个构造方法，在创建时可以记录异常信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();                           <span class="comment">// 默认</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>);                  <span class="comment">// 记录异常信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);                          <span class="comment">// 记录异常原因</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>, e);               <span class="comment">// 记录详细信息和异常原因</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<p>Throwable &#x2F; Exception 类定义了多种常用方法用于获取异常数据，常用的有：</p>
<ul>
<li>getMessage 方法：获取异常的信息。</li>
<li>getStackTrace 方法：获取的异常发生顺序。</li>
<li>printStackTrace 方法：获取异常的发生顺序并打印（开发和调试阶段用来显示异常信息，帮助开发者找出错误）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    e.printStacTrace();                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>我们也可以通过继承并重写 Exception &#x2F; RuntimeException 类的方式，自定义异常类并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义异常，重写方法可任选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message,cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常转译"><a href="#异常转译" class="headerlink" title="异常转译"></a>异常转译</h3><p>在项目开发过程中，当 Sevice&#x2F;DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。程序可以捕获原始异常，然后再抛出一个新的业务异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;SQL Error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 throw</h3><p>当方法执行出现问题时，方法就会创建异常对象并抛出。开发者可以在程序中自行抛出异常；JVM 在执行程序时发现问题也会自动抛出异常。</p>
<ul>
<li><p><strong>throw 语句</strong>：开发者自行创建异常对象并抛出，等待程序进行异常处理。</p>
</li>
<li><p><strong>throws 语句</strong>：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;       </span><br><span class="line">    <span class="comment">// 把方法中的抛出异常交给上层处理     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> IndexOutOfBoundsException, IOException&#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 用户自定义异常并抛出</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 虚拟机自动发现异常也会抛出，必须出现在 try 代码块中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(txt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-catch"><a href="#捕获异常-catch" class="headerlink" title="捕获异常 catch"></a>捕获异常 catch</h3><p>当方法执行抛出异常时，必须由专门的代码块对异常进行处理。</p>
<ul>
<li><p><strong>try 语句</strong>：可能出现异常的代码块。</p>
</li>
<li><p><strong>catch 语句</strong>：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。</p>
</li>
<li><p><strong>finally 语句</strong>：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><p>如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理。但必须在方法中声明 throws。</p>
</li>
<li><p>try&#x2F;catch 代码中的 return 语句会在执行完 finally 后再返回，但 finally 中对返回变量的改变不会影响最终的返回结果。</p>
</li>
<li><p>finally 代码中应避免含有 return 语句或抛出异常，否则只会执行 finally 中的 return 语句，且不会向上级抛出异常。</p>
</li>
</ol>
<p><em>Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;               </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<!--

**异常处理类**

在 Spring Boot 中，所有异常统一由专门的异常处理类`@ControllerAdvice`处理。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制器异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorHandler.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入参数校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NotValidExceptionHandler</span><span class="params">(HttpServletRequest req, MethodArgumentNotValidException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rfc4918 - 11.2. 422: Unprocessable Entity          </span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> MiscUtil.getValidateError(bindingResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.UNPROCESSABLE_ENTITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//404异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NoHandlerFoundExceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">404</span>, <span class="string">&quot;页面不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他默认异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">defaultHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-概念区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/" class="article-date">
  	<time datetime="2024-10-30T13:05:40.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/">
        概念区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###关键概念区别</p>
<p>####抽象类与接口</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>abstract  class</td>
<td>interface</td>
</tr>
<tr>
<td>概念</td>
<td>不能实例化的类，可能包含抽象方法</td>
<td>抽象方法和静态常量的集合</td>
</tr>
<tr>
<td>组成</td>
<td>抽象方法、普通方法、静态方法、变量、常量、静态变量、构造方法</td>
<td>抽象方法、静态常量</td>
</tr>
<tr>
<td>子类</td>
<td>子类继承抽象类</td>
<td>实现类实现接口</td>
</tr>
<tr>
<td>继承或实现关键字</td>
<td>extends</td>
<td>implements</td>
</tr>
<tr>
<td>局限性</td>
<td>单继承，可以多层继承</td>
<td>没有限制</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可以实现接口</td>
<td>接口不能继承抽象类</td>
</tr>
<tr>
<td>应用类</td>
<td>父类强制子类完成某些特定的功能，当然父类中也包含了共同的代码</td>
<td>约定、规范。 方法的描述，子类必须完成所有的方法</td>
</tr>
</tbody></table>
<p>####重写与重载</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重写</th>
<th>重载</th>
</tr>
</thead>
<tbody><tr>
<td>关键词</td>
<td>override</td>
<td>overload</td>
</tr>
<tr>
<td>概念</td>
<td>子类重写父类的方法</td>
<td>一个方法的多种展现形式</td>
</tr>
<tr>
<td>环境</td>
<td>子类和父类</td>
<td>一个类中</td>
</tr>
<tr>
<td>方法名</td>
<td>相同</td>
<td>相同</td>
</tr>
<tr>
<td>参数列表</td>
<td>相同</td>
<td>必须不同</td>
</tr>
<tr>
<td>返回值</td>
<td>相同</td>
<td>没有要求</td>
</tr>
<tr>
<td>访问权限</td>
<td>子类不能比父类更加严格</td>
<td>没有要求</td>
</tr>
<tr>
<td>异常</td>
<td>子类不能抛出比父类大的异常</td>
<td>没有要求</td>
</tr>
</tbody></table>
<hr>
<p>####this与super<br>总结：<strong>this是当前对象在堆空间的引用地址,super是当前对象的父类特征的引用</strong></p>
<p>super 只是记录对象内部的父类的特征(属性和方法)的一个引用</p>
<blockquote>
<p>这儿<strong>super不是指向父类对象的引用地址</strong>,new出来的才在堆里面分配空间有引用地址,这儿没有去new一个父类对象,只是执行了父类的构造函数将父类的特征生成了,但是属于New出来的那个子类对象的</p>
</blockquote>
<p>实践一下,你可以写</p>
<pre><code>public FatherClass getThis() 
&#123; 
return this; 
&#125; 
</code></pre>
<p>编译通过,没有任何问题<br>但是你写</p>
<pre><code>public FatherClass getSuper() 
&#123; 
return super; 
&#125; 
</code></pre>
<p>嘿嘿,编译出错! 为什么啦？</p>
<ul>
<li>因为super并不是一个堆空间里面的一个对象的引用地址,而this才是堆空间里面的一个对象的引用地址</li>
<li>super只能在对象内部使用,而this可以在对象内部使用也可以返回出对象外.</li>
<li>super是死的,编译的时候就定死了super的指向了,而this是活的,在运行时候决定其指向.</li>
</ul>
<p>解释一下:</p>
<blockquote>
<p>子类实例化对象,并没有去实例化他的父类对象,也就是说,那个子类对象里面并没有一个父类对象,那你说没有父类对象,为什么子类构造函数要执行父类的构造函数啦,那是因为需要创建父类的特征赋予子类,但是是由子类所有,而super就是用来区别是是否是父类对象的特征的.<br>重写父类方法属性,就是再创建了一个子类的特征,当你用this的时候,就覆盖了父类的特征了,但是父类特征还在那儿,用super就能访问到,但是只能在对象的内部使用.对象外面就只能看到覆盖了父类特征的子类特征了.</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td>this.属性名。只能访问当前对象所拥有的属性(包括继承来的属性，如果继承的属性名和子类对象相同，若不指定则调用子类的，调用父类的需要显示指定：super.属性名)</td>
<td>super.属性名。可以访问父类非私有的属性</td>
</tr>
<tr>
<td>访问方法</td>
<td>与访问属性类似</td>
<td>与访问属性类似</td>
</tr>
<tr>
<td>调用构造器</td>
<td>this(有参或无参)调用本类中有参或无参的构造函数，必须放在构造函数的第一句</td>
<td>super(有参还是无参)调用父类的有参或是无参的构造方法，必须放在构造方法的第一行（注意：**在同一个构造函数里不能同时出现this()和super()**）</td>
</tr>
<tr>
<td>指代</td>
<td>this是当前对象在堆空间的引用地址</td>
<td>super是当前对象的父类特征的引用</td>
</tr>
<tr>
<td>作为参数</td>
<td>this可以作为参数，它代表了当前对象的引用</td>
<td>super不可以</td>
</tr>
<tr>
<td>使用环境</td>
<td>不可以在static环境中使用</td>
<td>不可以在static环境中使用</td>
</tr>
</tbody></table>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  	<time datetime="2024-10-30T13:01:29.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
        面向对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><hr>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li><p><strong>面向过程</strong>：根据解决问题的过程，直接设计系统。如 C 语言。</p>
</li>
<li><p><strong>面向对象</strong>：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。</p>
<ul>
<li><p>特性：封装、继承、多态。</p>
</li>
<li><p>优点：使系统更加灵活，易维护、易复用、易扩展。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。</p>
<p>成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  </span><br><span class="line">        inner.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">myrifle</span> <span class="operator">=</span> f.getRifle();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">getRifle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">Gun</span> &#123;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rifle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。</p>
<p>最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类或接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123; </span><br><span class="line">            <span class="comment">// 定义匿名内部类并直接使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 无需外部对象，直接创建内部类</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类继承父类后，无需定义也可使用父类定义好的 public&#x2F;protected 方法和属性。也可以进行扩展和方法的重写。</p>
<ul>
<li>父类的<strong>属性值</strong>不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。</li>
<li>父类的 <strong>static 方法</strong>不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。</li>
<li>父类的<strong>构造方法</strong>不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trunk</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123; </span><br><span class="line">    <span class="comment">// 重定义属性（未公开无法继承）</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;this is a trunk&quot;</span>;</span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="type">int</span> goods;</span><br><span class="line">    <span class="comment">// 扩展方法              </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.goods += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trunk</span><span class="params">(String brand)</span>&#123;    </span><br><span class="line">        <span class="built_in">super</span>(brand);        </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.go(loc);                            </span><br><span class="line">        System.out.print(<span class="string">&quot; with&quot;</span> + goods + <span class="string">&quot;goods&quot;</span>); </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。</em></p>
<hr>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Charge</span> <span class="keyword">extends</span> <span class="title class_">Move</span>, Fight&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h3><ul>
<li><strong>重载</strong>(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。</li>
<li><strong>重写</strong>(override)：子类定义完全相同的方法覆盖父类。</li>
</ul>
<p>重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。</p>
<p><code>Car mycar = new Trunk(&quot;Benz&quot;);</code></p>
<p>但不允许子类引用指向父类对象。</p>
<p><del><code>Trunk mycar = new Car(&quot;Benz&quot;);</code></del></p>
<p>如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。</p>
<p><code>Trunk newCar = (Trunk)mycar; </code></p>
<h3 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h3><ul>
<li><p><strong>调用普通方法</strong></p>
<p>子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。</p>
</li>
<li><p><strong>调用 static &#x2F; private &#x2F; final 以及构造方法</strong></p>
<p>特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。</p>
</li>
<li><p><strong>调用成员变量</strong></p>
<p>父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trunk</span>(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line"></span><br><span class="line">myCar.go(<span class="string">&quot;London&quot;</span>);                    <span class="comment">// (trunk) go to London with 0 goods</span></span><br><span class="line">myCar.showNum();                       <span class="comment">// (car) 1</span></span><br><span class="line">System.out.print(myCar.description);   <span class="comment">// (car) this is a car</span></span><br><span class="line"></span><br><span class="line"><span class="type">Trunk</span> <span class="variable">newCar</span> <span class="operator">=</span> (Trunk)mycar;           <span class="comment">// 强制类型转换</span></span><br><span class="line">System.out.print(newCar.description);  <span class="comment">// (trunk) this is a trunk</span></span><br></pre></td></tr></table></figure>


<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性。</li>
</ul>
<p>通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。</p>
<p>但是在性能上会有较大的损耗。</p>
<p><em>尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。</em></p>
<h4 id="反射机制运用"><a href="#反射机制运用" class="headerlink" title="反射机制运用"></a>反射机制运用</h4><p>类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。</p>
<ul>
<li><strong>Class 类</strong>：类</li>
<li><strong>Constructor 类</strong>：类的构造方法</li>
<li><strong>Field 类</strong>：类的属性</li>
<li><strong>Method 类</strong>：类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 对象 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种方式 返回对象的类 【已有对象，获取类无意义】</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第三种方式 返回路径下的类 【常用】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 信息 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getName());   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getConstructors();</span><br><span class="line">        <span class="comment">// 获取类的全部构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取类的指定构造方法（参数）</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getConstructor(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getFields(); </span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取类的指定属性（属性名）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有方法</span></span><br><span class="line">        Method[] methodArray = stuClass.getMethods(); </span><br><span class="line">        <span class="comment">// 获取类的全部方法                </span></span><br><span class="line">        Method[] methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取类的指定方法（方法名+形参类型）                  </span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;main&quot;</span>, String.class);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 在对象中使用 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();   <span class="comment">// 调用公有无参构造方法创建对象</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;X-man&quot;</span>);              <span class="comment">// 为对象的公有属性赋值</span></span><br><span class="line">        m.invoke(obj, <span class="string">&quot;X-man&quot;</span>);           <span class="comment">// 调用对象的公有方法</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><a href="/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?id=%E6%B3%9B%E5%9E%8B">泛型</a>在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：</p>
<p><em>在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	</span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); </span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/hello-world/" class="article-date">
  	<time datetime="2024-10-30T11:51:07.500Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 Camellia
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>