<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Camellia">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="douban.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Camellia</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ymbyh/" title="github">github</a>
					        
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=32717172&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/ymbyh/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="douban.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ymbyh/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-java面试题01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/03/01/java%E9%9D%A2%E8%AF%95%E9%A2%9801/" class="article-date">
  	<time datetime="2025-03-01T03:00:12.000Z" itemprop="datePublished">2025-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/01/java%E9%9D%A2%E8%AF%95%E9%A2%9801/">
        java面试题01
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-后端开发面试题"><a href="#Java-后端开发面试题" class="headerlink" title="Java 后端开发面试题"></a>Java 后端开发面试题</h1><p>[TOC]</p>
<blockquote>
<p><strong>说明：</strong></p>
<p><strong>这份 Java 后端开发面试题是 ChatGPT 根据我的校招简历自动生成的有针对性的高频面试题，分为项目经验考察和专业技能考察两部分。</strong></p>
</blockquote>
<h2 id="第一章-项目经验"><a href="#第一章-项目经验" class="headerlink" title="第一章 项目经验"></a>第一章 项目经验</h2><h3 id="一、智慧星球——在线视频学习平台——微服务项目"><a href="#一、智慧星球——在线视频学习平台——微服务项目" class="headerlink" title="一、智慧星球——在线视频学习平台——微服务项目"></a>一、智慧星球——在线视频学习平台——微服务项目</h3><h4 id="1、简要介绍一下你参与的智慧星球项目的技术架构和主要功能。"><a href="#1、简要介绍一下你参与的智慧星球项目的技术架构和主要功能。" class="headerlink" title="1、简要介绍一下你参与的智慧星球项目的技术架构和主要功能。"></a>1、简要介绍一下你参与的智慧星球项目的技术架构和主要功能。</h4><p><strong>答案：</strong> 智慧星球是一个在线视频学习平台的微服务项目。它使用了 Spring Boot 和 Spring Cloud 作为基础框架，数据库采用 MySQL，ORM 框架使用 MyBatis Plus。主要功能包括后台管理系统的教师管理、课程分类管理、点播课程管理、订单管理、优惠券管理、公众号菜单管理、直播管理等功能。微信公众号实现了授权登录、课程浏览、购买、观看和分享、观看直播、消息自动回复等功能。</p>
<h4 id="2、请解释一下微服务架构，并说明为什么选择微服务架构作为该项目的架构方式。"><a href="#2、请解释一下微服务架构，并说明为什么选择微服务架构作为该项目的架构方式。" class="headerlink" title="2、请解释一下微服务架构，并说明为什么选择微服务架构作为该项目的架构方式。"></a>2、请解释一下微服务架构，并说明为什么选择微服务架构作为该项目的架构方式。</h4><p><strong>答案：</strong> 微服务架构是一种将应用程序拆分为一组小型、独立的服务的架构风格。在该项目中，采用微服务架构可以将不同的功能模块独立开发、部署和扩展，实现了高内聚、低耦合的目标。通过使用 Nacos 进行服务注册和发现，以及 OpenFeign 实现模块间的远程调用，可以更好地管理和扩展整个系统，提高系统的可维护性和可扩展性。</p>
<h4 id="3、在微服务架构中，如何处理服务之间的通信和数据传递？"><a href="#3、在微服务架构中，如何处理服务之间的通信和数据传递？" class="headerlink" title="3、在微服务架构中，如何处理服务之间的通信和数据传递？"></a>3、在微服务架构中，如何处理服务之间的通信和数据传递？</h4><p><strong>答案：</strong> 在微服务架构中，可以使用多种方式处理服务之间的通信和数据传递。在智慧星球项目中，采用了 Spring Cloud 提供的 OpenFeign 来实现模块间的远程调用，它基于 HTTP 协议，通过定义接口的方式来实现服务之间的通信。通过在接口上使用注解，可以指定远程服务的 URL 和参数，Spring Cloud 会自动处理远程调用和数据传递的细节，简化了开发和集成的过程。</p>
<h4 id="4、请解释一下-JWT-和-Token-鉴权的工作原理。"><a href="#4、请解释一下-JWT-和-Token-鉴权的工作原理。" class="headerlink" title="4、请解释一下 JWT 和 Token 鉴权的工作原理。"></a>4、请解释一下 JWT 和 Token 鉴权的工作原理。</h4><p><strong>答案：</strong> JWT（JSON Web Token）是一种用于在网络应用间传递信息的安全方法。它由三部分组成，分别是头部（Header）、载荷（Payload）和签名（Signature）。</p>
<p>工作原理如下：</p>
<ol>
<li><p>用户在登录成功后，服务端生成一个包含用户信息的 Token，并将其发送给客户端。</p>
</li>
<li><p>客户端在后续的请求中将该 Token 携带在请求头中。</p>
</li>
<li><p>服务端在接收到请求时，将从 Token 中解析出的用户信息用于权限验证和业务操作。</p>
</li>
<li><p>服务端使用秘钥对 Token 进行签名，确保 Token 的完整性和安全性。</p>
</li>
</ol>
<h4 id="5、请解释一下微信授权登录的流程。"><a href="#5、请解释一下微信授权登录的流程。" class="headerlink" title="5、请解释一下微信授权登录的流程。"></a>5、请解释一下微信授权登录的流程。</h4><p><strong>答案：</strong> 微信授权登录是通过使用微信开放平台的 OAuth2.0 协议实现的。</p>
<p>流程如下：</p>
<ol>
<li><p>用户在微信客户端点击授权登录按钮。</p>
</li>
<li><p>微信客户端跳转到开发者配置的授权页面，并向用户展示授权请求。</p>
</li>
<li><p>用户同意授权后，微信客户端将用户重定向到开发者指定的回调 URL，并附带授权临时票据 code。</p>
</li>
<li><p>开发者通过后端服务器接收到 code 后，使用 code 和 AppID、AppSecret 等参数向微信服务器发送请求，获取访问令牌（access_token）和用户唯一标识（openid）等信息。</p>
</li>
<li><p>开发者可以使用 access_token 和 openid 进行用户认证和授权操作。</p>
</li>
</ol>
<h4 id="6、请说明项目中使用的腾讯云对象存储、视频点播和欢拓云直播的作用和实现方式。"><a href="#6、请说明项目中使用的腾讯云对象存储、视频点播和欢拓云直播的作用和实现方式。" class="headerlink" title="6、请说明项目中使用的腾讯云对象存储、视频点播和欢拓云直播的作用和实现方式。"></a>6、请说明项目中使用的腾讯云对象存储、视频点播和欢拓云直播的作用和实现方式。</h4><p><strong>答案：</strong> 腾讯云对象存储用于实现图片上传，视频点播用于实现视频的存储和播放，欢拓云直播用于实现直播功能。在项目中，通过集成相应的 SDK 或 API，可以使用腾讯云对象存储的接口实现图片的上传和访问，使用腾讯云视频点播的接口实现视频的上传和播放，使用欢拓云直播的接口实现直播的观看和管理。</p>
<h4 id="7、请介绍一下项目中使用的-EasyExcel-和-ECharts-的作用以及实现方式。"><a href="#7、请介绍一下项目中使用的-EasyExcel-和-ECharts-的作用以及实现方式。" class="headerlink" title="7、请介绍一下项目中使用的 EasyExcel 和 ECharts 的作用以及实现方式。"></a>7、请介绍一下项目中使用的 EasyExcel 和 ECharts 的作用以及实现方式。</h4><p><strong>答案：</strong> EasyExcel 是一个 Java 处理 Excel 文件的开源库，用于读写 Excel 数据。在项目中，通过使用 EasyExcel，可以方便地读取和写入 Excel 文件，实现课程分类管理中的数据导入和导出功能。ECharts 是一个用于绘制图表的 JavaScript 库，用于展示视频的播放量。通过使用 ECharts，可以将视频播放量的数据进行可视化展示，例如绘制折线图。</p>
<h4 id="8、请说明项目中使用的-Swagger-的作用和实现方式。"><a href="#8、请说明项目中使用的-Swagger-的作用和实现方式。" class="headerlink" title="8、请说明项目中使用的 Swagger 的作用和实现方式。"></a>8、请说明项目中使用的 Swagger 的作用和实现方式。</h4><p><strong>答案：</strong> Swagger 是一个用于生成接口文档和测试接口的工具。在该项目中，通过集成 Swagger，可以自动生成项目的接口文档，并提供了一个可视化的界面供开发人员查看和测试接口。开发人员可以通过配置注解来描述接口的信息和参数，并使用 Swagger UI 来展示接口文档，并提供接口测试的功能。</p>
<h3 id="二、简易的-IOC-和-DispatcherServlet-Web-应用程序"><a href="#二、简易的-IOC-和-DispatcherServlet-Web-应用程序" class="headerlink" title="二、简易的 IOC 和 DispatcherServlet Web 应用程序"></a>二、简易的 IOC 和 DispatcherServlet Web 应用程序</h3><h4 id="1、请简要介绍一下你在这个项目中实现的-IOC-容器的原理和工作流程。"><a href="#1、请简要介绍一下你在这个项目中实现的-IOC-容器的原理和工作流程。" class="headerlink" title="1、请简要介绍一下你在这个项目中实现的 IOC 容器的原理和工作流程。"></a>1、请简要介绍一下你在这个项目中实现的 IOC 容器的原理和工作流程。</h4><p><strong>答案：</strong> 在这个项目中，我实现的 IOC（Inversion of Control）容器的原理和工作流程如下：</p>
<ol>
<li><p>加载配置文件：首先，IOC 容器会读取指定的 XML 配置文件，其中包含了 Bean 的定义信息，包括类名、属性、依赖等。</p>
</li>
<li><p>创建对象实例：IOC 容器通过反射机制根据配置文件中的类名，动态地创建对象实例。它会调用类的构造函数来实例化对象。</p>
</li>
<li><p>处理对象依赖：一旦对象实例化完成，IOC 容器会检查对象的依赖关系。它会根据配置文件中的依赖信息，自动解析对象之间的依赖关系。</p>
</li>
<li><p>注入依赖：IOC 容器将会自动将依赖对象注入到相应的属性中。它通过调用对象的 setter 方法来完成属性的注入。</p>
</li>
<li><p>提供对象实例：一旦所有的对象都被创建和注入完成，IOC 容器会将这些对象保存起来，并且可以根据需要提供对象的实例。其他组件可以通过容器来获取所需的对象实例，实现了对象的解耦和灵活的组装。</p>
</li>
</ol>
<p>总结起来，IOC 容器的核心思想是通过控制反转的方式，将对象的创建和依赖管理交给容器来完成。它通过读取配置文件、反射机制和依赖注入等技术，实现了对象的动态创建和组装。这样可以大大降低组件之间的耦合度，提高代码的可维护性和灵活性。</p>
<h4 id="2、你是如何设计和实现-DispatcherServlet-中央控制器的？请谈谈你的思路和关键步骤。"><a href="#2、你是如何设计和实现-DispatcherServlet-中央控制器的？请谈谈你的思路和关键步骤。" class="headerlink" title="2、你是如何设计和实现 DispatcherServlet 中央控制器的？请谈谈你的思路和关键步骤。"></a>2、你是如何设计和实现 DispatcherServlet 中央控制器的？请谈谈你的思路和关键步骤。</h4><p><strong>答案：</strong> 在设计和实现 DispatcherServlet 中央控制器时，我采用了以下思路和关键步骤：</p>
<ol>
<li><p>配置 URL 映射规则：在项目的配置文件中，我定义了 URL 与 Controller 方法之间的映射规则。这可以通过配置文件、注解或编程方式完成。例如，可以使用 XML 配置文件或注解来指定 URL 与 Controller 方法的对应关系。</p>
</li>
<li><p>请求的处理流程：当收到一个请求时，DispatcherServlet 作为中央控制器，接收并处理该请求。它首先根据请求的 URL 查找对应的 Controller 类和方法。</p>
</li>
<li><p>动态加载 Controller 类：利用 Java 的反射机制，我动态加载对应的 Controller 类。这样可以根据配置的类路径创建 Controller 类的实例。</p>
</li>
<li><p>调用 Controller 方法：通过反射，我调用 Controller 类中与 URL 对应的方法来处理请求。这些方法通常包含了业务逻辑和数据处理操作。传递给 Controller 方法的参数可以是请求参数、表单数据或其他需要的参数。</p>
</li>
<li><p>处理结果返回：Controller 方法执行完后，会返回一个表示处理结果的对象。DispatcherServlet 将该结果转换为适当的响应格式（如 HTML、JSON 等），并将其返回给客户端。</p>
</li>
</ol>
<p>总结起来，设计和实现 DispatcherServlet 中央控制器的关键步骤包括 URL 映射规则的配置、根据 URL 查找对应的 Controller 类和方法、动态加载 Controller 类、通过反射调用 Controller 方法处理请求，并将处理结果返回给客户端。这种设计模式可以实现一种灵活的、可扩展的请求处理方式，使得开发者能够更好地组织和管理 Web 应用的请求处理逻辑。</p>
<h4 id="3、你在项目中实现的-Filter-和-Listener-组件的作用是什么？请谈谈你是如何应用它们的。"><a href="#3、你在项目中实现的-Filter-和-Listener-组件的作用是什么？请谈谈你是如何应用它们的。" class="headerlink" title="3、你在项目中实现的 Filter 和 Listener 组件的作用是什么？请谈谈你是如何应用它们的。"></a>3、你在项目中实现的 Filter 和 Listener 组件的作用是什么？请谈谈你是如何应用它们的。</h4><p><strong>答案：</strong> Filter 和 Listener 组件在项目中起到了全局预处理和后处理的作用。Filter 组件可以用于拦截请求，进行一些通用的预处理操作，如解决跨域和设置编码等。Listener 组件可以监听 Web 应用的生命周期事件，如应用启动和关闭等，进行一些特定的操作。在这个项目中，我应用了 Filter 组件来处理请求的全局预处理，例如解决跨域和设置编码。同时，我也应用了 Listener 组件来监听应用的启动事件，进行一些初始化操作。</p>
<h4 id="4、你在项目中应用了哪些设计模式？请列举并解释一下你为什么选择这些设计模式。"><a href="#4、你在项目中应用了哪些设计模式？请列举并解释一下你为什么选择这些设计模式。" class="headerlink" title="4、你在项目中应用了哪些设计模式？请列举并解释一下你为什么选择这些设计模式。"></a>4、你在项目中应用了哪些设计模式？请列举并解释一下你为什么选择这些设计模式。</h4><p><strong>答案：</strong> 在这个项目中，我应用了以下设计模式：</p>
<ul>
<li><p>单例模式：用于确保 IOC 容器和 DispatcherServlet 中央控制器的单一实例，避免重复创建和资源浪费。</p>
</li>
<li><p>工厂模式：用于创建对象实例，将对象的创建过程封装起来，使得代码更具可读性和可维护性。</p>
</li>
<li><p>代理模式：用于实现 AOP（面向切面编程），通过代理对象对目标对象进行包装，实现横切关注点的统一处理。</p>
</li>
<li><p>前端控制器模式：用于将请求的分发和处理集中到一个中央控制器，提高代码的可维护性和灵活性。</p>
</li>
<li><p>策略模式：用于实现不同的请求处理策略，根据请求的不同类型选择相应的处理逻辑。</p>
</li>
<li><p>模板视图模式：用于将视图的渲染和展示逻辑与业务逻辑分离，实现解耦和重用。</p>
</li>
</ul>
<h2 id="第二章-专业技能"><a href="#第二章-专业技能" class="headerlink" title="第二章 专业技能"></a>第二章 专业技能</h2><h3 id="一、熟悉-Java-基本语法和面向对象思想，熟悉-Java-集合框架，理解多线程编程，了解-JDK-21-虚拟线程新特性。"><a href="#一、熟悉-Java-基本语法和面向对象思想，熟悉-Java-集合框架，理解多线程编程，了解-JDK-21-虚拟线程新特性。" class="headerlink" title="一、熟悉 Java 基本语法和面向对象思想，熟悉 Java 集合框架，理解多线程编程，了解 JDK 21 虚拟线程新特性。"></a>一、熟悉 Java 基本语法和面向对象思想，熟悉 Java 集合框架，理解多线程编程，了解 JDK 21 虚拟线程新特性。</h3><h4 id="1、Java-中的继承和多态有什么区别？"><a href="#1、Java-中的继承和多态有什么区别？" class="headerlink" title="1、Java 中的继承和多态有什么区别？"></a>1、Java 中的继承和多态有什么区别？</h4><p><strong>答案：</strong> 继承是一种机制，它允许一个类继承另一个类的属性和方法。子类可以继承父类的非私有成员，并且可以通过重写方法来改变其行为。多态是指同一类型的对象调用同一方法时，可能会产生不同的行为。它可以通过方法的重写和方法的重载来实现。</p>
<h4 id="2、Java-中的接口和抽象类有什么区别？"><a href="#2、Java-中的接口和抽象类有什么区别？" class="headerlink" title="2、Java 中的接口和抽象类有什么区别？"></a>2、Java 中的接口和抽象类有什么区别？</h4><p><strong>答案：</strong> 接口是一种完全抽象的类，其中只定义了方法的签名而没有方法的实现。它提供了一种规范，用于定义类应该实现的方法。抽象类是一个可以包含抽象方法和具体方法的类，它不能被实例化，只能被继承。区别在于，一个类可以实现多个接口，但只能继承一个抽象类。</p>
<h4 id="3、Java-中的-ArrayList-和-LinkedList-有什么区别？"><a href="#3、Java-中的-ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="3、Java 中的 ArrayList 和 LinkedList 有什么区别？"></a>3、Java 中的 ArrayList 和 LinkedList 有什么区别？</h4><p><strong>答案：</strong> ArrayList 和 LinkedList 都是 Java 集合框架中的实现类。ArrayList 基于动态数组实现，它支持随机访问和快速的插入&#x2F;删除操作。LinkedList 基于链表实现，它支持高效的插入&#x2F;删除操作，但对于随机访问的效率较低。</p>
<h4 id="4、什么是-Java-中的线程？如何创建和启动一个线程？"><a href="#4、什么是-Java-中的线程？如何创建和启动一个线程？" class="headerlink" title="4、什么是 Java 中的线程？如何创建和启动一个线程？"></a>4、什么是 Java 中的线程？如何创建和启动一个线程？</h4><p><strong>答案：</strong> 线程是执行单元，用于实现并发执行。在 Java 中，可以通过两种方式创建线程：继承 Thread 类，重写 run()方法，并调用 start()方法；或者实现 Runnable 接口，实现 run()方法，并创建 Thread 对象来包装 Runnable 实例。通过调用 Thread 的 start()方法来启动线程。</p>
<h4 id="5、如何实现线程同步？请举例说明。"><a href="#5、如何实现线程同步？请举例说明。" class="headerlink" title="5、如何实现线程同步？请举例说明。"></a>5、如何实现线程同步？请举例说明。</h4><p><strong>答案：</strong> 可以使用 Java 中的关键字 synchronized 来实现线程同步。它可以修饰方法或代码块，确保在同一时间只有一个线程可以访问被修饰的代码。例如，可以使用 synchronized 关键字修饰一个共享资源的访问方法，以避免多个线程同时修改该资源。</p>
<h4 id="6、Java-中的-Lock-和-synchronized-的区别是什么？"><a href="#6、Java-中的-Lock-和-synchronized-的区别是什么？" class="headerlink" title="6、Java 中的 Lock 和 synchronized 的区别是什么？"></a>6、Java 中的 Lock 和 synchronized 的区别是什么？</h4><p><strong>答案：</strong> Lock 是 Java 并发包提供的一种机制，用于实现线程同步。与 synchronized 不同，Lock 是显式地获取和释放锁，可以实现更细粒度的线程控制，可以通过 lock()和 unlock()方法手动控制锁的获取和释放。相对而言，synchronized 是隐式地获取和释放锁，简单易用，但对控制粒度较低。</p>
<h4 id="7、什么是-Java-中的线程池？它有什么好处？"><a href="#7、什么是-Java-中的线程池？它有什么好处？" class="headerlink" title="7、什么是 Java 中的线程池？它有什么好处？"></a>7、什么是 Java 中的线程池？它有什么好处？</h4><p><strong>答案：</strong> 线程池是一组预先创建的线程，用于执行提交的任务。它可以避免为每个任务创建新线程的开销，并提供对线程的管理和复用。线程池的好处包括提高性能和资源利用率、控制并发线程数、提供任务排队和调度等。</p>
<h4 id="8、Java-中的并发容器有哪些？"><a href="#8、Java-中的并发容器有哪些？" class="headerlink" title="8、Java 中的并发容器有哪些？"></a>8、Java 中的并发容器有哪些？</h4><p><strong>答案：</strong> Java 中的并发容器包括 ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentSkipListSet 等。这些容器提供了线程安全的操作，并且能够高效地支持并发访问。</p>
<h4 id="9、如何在-Java-中处理线程间的通信？"><a href="#9、如何在-Java-中处理线程间的通信？" class="headerlink" title="9、如何在 Java 中处理线程间的通信？"></a>9、如何在 Java 中处理线程间的通信？</h4><p><strong>答案：</strong> 在 Java 中，可以使用以下方法来处理线程间的通信：</p>
<ul>
<li><p>使用共享变量：多个线程共享一个变量，并通过 synchronized 关键字或其他同步机制确保线程之间的可见性和一致性。</p>
</li>
<li><p>使用 wait()和 notify()&#x2F;notifyAll()方法：通过 Object 类提供的 wait()方法使线程进入等待状态，然后使用 notify()或 notifyAll()方法唤醒等待的线程。</p>
</li>
<li><p>使用线程安全的队列：例如，BlockingQueue 可以用于在生产者和消费者之间进行安全的数据交换。</p>
</li>
</ul>
<h4 id="10、请解释一下-JDK-21-中的虚拟线程（Virtual-Threads）新特性，并提供一个示例代码来说明其用法。"><a href="#10、请解释一下-JDK-21-中的虚拟线程（Virtual-Threads）新特性，并提供一个示例代码来说明其用法。" class="headerlink" title="10、请解释一下 JDK 21 中的虚拟线程（Virtual Threads）新特性，并提供一个示例代码来说明其用法。"></a>10、请解释一下 JDK 21 中的虚拟线程（Virtual Threads）新特性，并提供一个示例代码来说明其用法。</h4><p><strong>答案：</strong> JDK 21 引入了虚拟线程（Virtual Threads）作为一项新特性，旨在提高 Java 应用程序的并发性能和资源利用率。虚拟线程是一种轻量级的线程模型，可以更高效地执行异步代码，避免了传统线程模型中线程的创建和销毁开销，提供更高的并发性和更低的资源消耗。</p>
<p>虚拟线程的主要特点包括：</p>
<ul>
<li><p>轻量级：虚拟线程比传统线程更轻量级，可以创建和销毁更快，减少了线程切换的开销。</p>
</li>
<li><p>可扩展性：虚拟线程可以在一个或多个平台线程上运行，可以根据应用程序的需求动态调整线程数量。</p>
</li>
<li><p>高并发性：虚拟线程可以更好地利用系统资源，提供更高的并发性能。</p>
</li>
<li><p>低资源消耗：由于虚拟线程的轻量级特性，它们消耗的资源更少，可以更好地管理系统资源。</p>
</li>
</ul>
<p>示例代码：</p>
<p>下面是一个使用虚拟线程进行异步操作的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor())</span><br><span class="line">        &#123;</span><br><span class="line">            IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; &#123;</span><br><span class="line">                executor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(Duration.ofSeconds(<span class="number">1</span>).toMillis());</span><br><span class="line">                        System.out.println(<span class="string">&quot;任务 &quot;</span> + i + <span class="string">&quot; 被提交&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，使用了 <code>Executors.newVirtualThreadPerTaskExecutor()</code> 方法创建了一个虚拟线程池，并使用 <code>executor.submit()</code> 方法提交了一些异步任务。每个任务会休眠 1 秒钟，然后打印出任务完成的消息。通过使用虚拟线程，我们可以以更高效的方式处理并发任务。</p>
<h3 id="二、熟悉常见数据结构和算法，如快速排序、二分查找等，熟悉常用的设计模式，如单例、工厂、代理等。"><a href="#二、熟悉常见数据结构和算法，如快速排序、二分查找等，熟悉常用的设计模式，如单例、工厂、代理等。" class="headerlink" title="二、熟悉常见数据结构和算法，如快速排序、二分查找等，熟悉常用的设计模式，如单例、工厂、代理等。"></a>二、熟悉常见数据结构和算法，如快速排序、二分查找等，熟悉常用的设计模式，如单例、工厂、代理等。</h3><h4 id="1、描述快速排序算法的原理，并给出相应的-Java-代码示例。"><a href="#1、描述快速排序算法的原理，并给出相应的-Java-代码示例。" class="headerlink" title="1、描述快速排序算法的原理，并给出相应的 Java 代码示例。"></a>1、描述快速排序算法的原理，并给出相应的 Java 代码示例。</h4><p><strong>答案：</strong> 快速排序是一种常见的排序算法，基本思想是通过分治法将一个数组分成两个子数组，然后对这两个子数组进行递归排序。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>从数组中选择一个元素作为基准（通常选择第一个或最后一个元素）。</p>
</li>
<li><p>将数组划分为两个子数组，小于基准的元素放在左侧，大于基准的元素放在右侧。</p>
</li>
<li><p>对左右子数组递归应用快速排序算法。</p>
</li>
<li><p>合并左子数组、基准元素和右子数组，得到最终排序结果。</p>
</li>
</ol>
<p>下面是 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, i + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">QuickSort.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[1, 2, 5, 7, 8, 9]</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<h4 id="2、二分查找是一种高效的查找算法，请描述其原理，并给出相应的-Java-代码示例。"><a href="#2、二分查找是一种高效的查找算法，请描述其原理，并给出相应的-Java-代码示例。" class="headerlink" title="2、二分查找是一种高效的查找算法，请描述其原理，并给出相应的 Java 代码示例。"></a>2、二分查找是一种高效的查找算法，请描述其原理，并给出相应的 Java 代码示例。</h4><p><strong>答案</strong>：二分查找是一种在有序数组中查找特定元素的算法，基本思想是通过比较中间元素与目标元素的大小关系，不断缩小查找范围。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>初始化左指针 <code>left</code> 和右指针 <code>right</code>，分别指向数组的第一个元素和最后一个元素。</p>
</li>
<li><p>计算中间元素的索引 <code>mid</code>，即 <code>mid = (left + right) / 2</code>。</p>
</li>
<li><p>比较中间元素与目标元素的大小关系：</p>
<ul>
<li><p>如果中间元素等于目标元素，则找到目标元素，返回索引。</p>
</li>
<li><p>如果中间元素大于目标元素，则目标元素可能在左半部分，将右指针 <code>right</code> 更新为 <code>mid - 1</code>。</p>
</li>
<li><p>如果中间元素小于目标元素，则目标元素可能在右半部分，将左指针 <code>left</code> 更新为 <code>mid + 1</code>。</p>
</li>
</ul>
</li>
<li><p>重复步骤 2 和步骤 3，直到找到目标元素或左指针大于右指针。</p>
</li>
</ol>
<p>下面是 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标元素不存在</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> BinarySearch.binarySearch(arr, target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：目标元素的索引：3</span></span><br><span class="line">System.out.println(<span class="string">&quot;目标元素的索引：&quot;</span> + index);</span><br></pre></td></tr></table></figure>

<h4 id="3、单例设计模式是一种常见的设计模式，请给出一个线程安全的单例模式的-Java-代码示例，并解释其原理。"><a href="#3、单例设计模式是一种常见的设计模式，请给出一个线程安全的单例模式的-Java-代码示例，并解释其原理。" class="headerlink" title="3、单例设计模式是一种常见的设计模式，请给出一个线程安全的单例模式的 Java 代码示例，并解释其原理。"></a>3、单例设计模式是一种常见的设计模式，请给出一个线程安全的单例模式的 Java 代码示例，并解释其原理。</h4><p><strong>答案：</strong> 单例设计模式旨在保证一个类只有一个实例，并提供一个全局访问点。</p>
<p>下面是一个线程安全的单例模式的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现使用了懒加载的方式，在第一次调用 <code>getInstance()</code> 方法时创建实例。通过将 <code>getInstance()</code> 方法设为 <code>synchronized</code>，可以保证线程安全，即每次只有一个线程可以进入该方法，避免了并发创建实例的问题。</p>
<h4 id="4、工厂模式是一种常见的设计模式，请给出一个工厂模式的-Java-代码示例，并解释其原理。"><a href="#4、工厂模式是一种常见的设计模式，请给出一个工厂模式的-Java-代码示例，并解释其原理。" class="headerlink" title="4、工厂模式是一种常见的设计模式，请给出一个工厂模式的 Java 代码示例，并解释其原理。"></a>4、工厂模式是一种常见的设计模式，请给出一个工厂模式的 Java 代码示例，并解释其原理。</h4><p><strong>答案：</strong> 工厂模式旨在通过工厂类创建对象，而不是直接使用 <code>new</code> 关键字实例化对象。</p>
<p>下面是一个简单的工厂模式的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">createShape</span><span class="params">(String type)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;circle&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;rectangle&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported shape type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Shape</code> 接口定义了绘制形状的方法，<code>Circle</code> 和 <code>Rectangle</code> 是实现了 <code>Shape</code> 接口的具体形状类。<code>ShapeFactory</code> 是工厂类，根据传入的参数 <code>type</code> 创建相应的形状对象。通过使用工厂模式，客户端代码可以通过工厂类创建对象，而无需直接与具体的形状类耦合。</p>
<h4 id="5、代理模式是一种常见的设计模式，请给出一个静态代理模式的-Java-代码示例，并解释其原理。"><a href="#5、代理模式是一种常见的设计模式，请给出一个静态代理模式的-Java-代码示例，并解释其原理。" class="headerlink" title="5、代理模式是一种常见的设计模式，请给出一个静态代理模式的 Java 代码示例，并解释其原理。"></a>5、代理模式是一种常见的设计模式，请给出一个静态代理模式的 Java 代码示例，并解释其原理。</h4><p><strong>答案：</strong> 代理模式旨在为其他对象提供一种代理，以控制对该对象的访问。</p>
<p>下面是一个静态代理模式的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealImage</span><span class="params">(String filename)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.filename = filename;</span><br><span class="line">        loadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadFromDisk</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从磁盘加载图片：&quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示图片：&quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(String filename)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> <span class="title class_">RealImage</span>(filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Image</code> 接口定义了显示图片的方法，<code>RealImage</code> 是实现了 <code>Image</code> 接口的具体图片类，<code>ImageProxy</code> 是代理类。当调用 <code>display()</code> 方法时，<code>ImageProxy</code> 会先检查 <code>realImage</code>是否已经创建了真实图片对象。如果已经创建，则直接调用真实图片对象的 <code>display()</code> 方法显示图片；如果尚未创建，则先创建真实图片对象，然后调用其 <code>display()</code> 方法显示图片。通过使用代理模式，可以在访问真实图片对象之前或之后执行一些额外的操作，例如加载图片、权限验证等。</p>
<h4 id="6、请解释什么是链表（LinkedList）数据结构，并给出一个-Java-代码示例。"><a href="#6、请解释什么是链表（LinkedList）数据结构，并给出一个-Java-代码示例。" class="headerlink" title="6、请解释什么是链表（LinkedList）数据结构，并给出一个 Java 代码示例。"></a>6、请解释什么是链表（LinkedList）数据结构，并给出一个 Java 代码示例。</h4><p><strong>答案：</strong> 链表是一种常见的动态数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用。链表中的节点不一定是连续存储的，而是通过指针或引用链接在一起。链表分为单向链表和双向链表两种形式。</p>
<p>下面是一个单向链表的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curr.next != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">list.insert(<span class="number">1</span>);</span><br><span class="line">list.insert(<span class="number">2</span>);</span><br><span class="line">list.insert(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1 2 3</span></span><br><span class="line">list.display();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>ListNode</code> 是链表的节点类，包含一个值 <code>val</code> 和一个指向下一个节点的引用 <code>next</code>。<code>LinkedList</code> 是链表类，具有插入节点和显示链表的功能。通过调用 <code>insert()</code> 方法插入节点，并通过调用 <code>display()</code> 方法显示链表的内容。</p>
<h4 id="7、请解释什么是栈（Stack）数据结构，并给出一个-Java-代码示例。"><a href="#7、请解释什么是栈（Stack）数据结构，并给出一个-Java-代码示例。" class="headerlink" title="7、请解释什么是栈（Stack）数据结构，并给出一个 Java 代码示例。"></a>7、请解释什么是栈（Stack）数据结构，并给出一个 Java 代码示例。</h4><p><strong>答案：</strong> 栈是一种常见的线性数据结构，遵循后进先出（Last-In-First-Out，LIFO）的原则。栈中的元素只能在栈顶进行插入和删除操作。栈的插入操作称为入栈（push），删除操作称为出栈（pop）。</p>
<p>下面是一个栈的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> top == data.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StackOverflowError</span>(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[++top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：3</span></span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：2</span></span><br><span class="line">System.out.println(stack.peek());</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Stack</code> 类使用数组实现了栈数据结构。<code>data</code> 数组用于存储栈中的元素，<code>top</code> 表示栈顶的索引。通过调用 <code>push()</code> 方法将元素入栈，调用 <code>pop()</code> 方法将元素出栈，调用 <code>peek()</code> 方法获取栈顶元素而不删除它。通过 <code>isEmpty()</code> 和 <code>isFull()</code> 方法可以判断栈是否为空或已满。</p>
<h4 id="8、请解释什么是队列（Queue）数据结构，并给出一个-Java-代码示例"><a href="#8、请解释什么是队列（Queue）数据结构，并给出一个-Java-代码示例" class="headerlink" title="8、请解释什么是队列（Queue）数据结构，并给出一个 Java 代码示例"></a>8、请解释什么是队列（Queue）数据结构，并给出一个 Java 代码示例</h4><p><strong>答案：</strong> 队列是一种常见的线性数据结构，遵循先进先出（First-In-First-Out，FIFO）的原则。队列中的元素只能在队尾插入（入队）和在队头删除（出队）。新元素插入的一端称为队尾，已有元素删除的一端称为队头。</p>
<p>下面是一个队列的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        queue.offer(<span class="number">2</span>);</span><br><span class="line">        queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用 Java 标准库中的 <code>Queue</code> 接口和 <code>LinkedList</code> 类实现了队列。通过调用 <code>offer()</code> 方法将元素入队，调用 <code>poll()</code> 方法将元素出队，并使用 <code>isEmpty()</code> 方法检查队列是否为空。</p>
<p>请注意，Java 标准库中的 <code>Queue</code> 接口还提供了其他操作，例如 <code>peek()</code> 方法用于获取队头元素但不删除它，<code>size()</code> 方法用于获取队列中元素的数量等。具体使用哪些操作取决于需求。</p>
<h4 id="9、什么是哈希表（HashTable）数据结构，并给出一个-Java-代码示例。"><a href="#9、什么是哈希表（HashTable）数据结构，并给出一个-Java-代码示例。" class="headerlink" title="9、什么是哈希表（HashTable）数据结构，并给出一个 Java 代码示例。"></a>9、什么是哈希表（HashTable）数据结构，并给出一个 Java 代码示例。</h4><p><strong>答案：</strong> 哈希表（HashTable）是一种常见的数据结构，用于存储键值对（Key-Value）。它通过哈希函数将键映射到数组中的特定位置，以实现高效的插入、删除和查找操作。</p>
<p>下面是一个使用 Java 中的<code>HashMap</code>类实现的哈希表示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTableExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加键值对</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        <span class="comment">// 输出：30</span></span><br><span class="line">        System.out.println(hashMap.get(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查键是否存在</span></span><br><span class="line">        <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除键值对</span></span><br><span class="line">        hashMap.remove(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (String key : hashMap.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用 Java 标准库中的<code>HashMap</code>类实现了哈希表。通过调用<code>put(key, value)</code>方法可以添加键值对，通过调用<code>get(key)</code>方法可以获取键对应的值，通过调用<code>containsKey(key)</code>方法可以检查键是否存在，通过调用<code>remove(key)</code>方法可以删除键值对。此外，可以使用<code>keySet()</code>方法获取哈希表中所有键的集合，并通过迭代集合获取键和对应的值。</p>
<p>需要注意的是，哈希表的具体实现可能不同，但主要思想是使用哈希函数将键映射到数组中的位置，以提高插入、删除和查找操作的效率。</p>
<h4 id="10、什么是二叉树（Binary-Tree）数据结构，并给出一个-Java-代码示例。"><a href="#10、什么是二叉树（Binary-Tree）数据结构，并给出一个-Java-代码示例。" class="headerlink" title="10、什么是二叉树（Binary Tree）数据结构，并给出一个 Java 代码示例。"></a>10、什么是二叉树（Binary Tree）数据结构，并给出一个 Java 代码示例。</h4><p><strong>答案：</strong> 二叉树（Binary Tree）是一种常见的树形数据结构，由节点组成，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树具有递归性质，每个节点都可以看作是根节点，其左子树和右子树也是二叉树。</p>
<p>下面是一个二叉树的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建二叉树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        preOrderTraversal(root);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">        postOrderTraversal(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            preOrderTraversal(root.left);</span><br><span class="line">            preOrderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inOrderTraversal(root.left);</span><br><span class="line">            System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            inOrderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            postOrderTraversal(root.left);</span><br><span class="line">            postOrderTraversal(root.right);</span><br><span class="line">            System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>TreeNode</code> 是二叉树的节点类，包含一个值 <code>val</code>，以及左子节点 <code>left</code> 和右子节点 <code>right</code>。<code>BinaryTreeExample</code> 类创建了一个二叉树，并实现了三种常见的遍历方法：前序遍历、中序遍历和后序遍历。</p>
<p>前序遍历按照根节点、左子树、右子树的顺序遍历节点；中序遍历按照左子树、根节点、右子树的顺序遍历节点；后序遍历按照左子树、右子树、根节点的顺序遍历节点。</p>
<p>在示例中，通过调用 <code>preOrderTraversal()</code>、<code>inOrderTraversal()</code> 和 <code>postOrderTraversal()</code> 方法可以遍历二叉树，并按照不同的顺序输出节点的值。</p>
<h3 id="三、熟悉-MySQL-的基本操作，如数据库设计、SQL-查询优化、事务处理、分库分表等。"><a href="#三、熟悉-MySQL-的基本操作，如数据库设计、SQL-查询优化、事务处理、分库分表等。" class="headerlink" title="三、熟悉 MySQL 的基本操作，如数据库设计、SQL 查询优化、事务处理、分库分表等。"></a>三、熟悉 MySQL 的基本操作，如数据库设计、SQL 查询优化、事务处理、分库分表等。</h3><h4 id="1、什么是索引？为什么使用索引？请举例说明如何创建索引。"><a href="#1、什么是索引？为什么使用索引？请举例说明如何创建索引。" class="headerlink" title="1、什么是索引？为什么使用索引？请举例说明如何创建索引。"></a>1、什么是索引？为什么使用索引？请举例说明如何创建索引。</h4><p><strong>答案：</strong> 索引是一种数据结构，用于加快数据库查询的速度。它类似于书籍的目录，可以根据关键字快速定位到对应的数据。</p>
<p>创建索引的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure>

<p>例如，创建一个名为”idx_username”的索引，用于提高对”user”表中的”username”列的查询速度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_username <span class="keyword">ON</span> <span class="keyword">user</span> (username);</span><br></pre></td></tr></table></figure>

<h4 id="2、什么是-SQL-查询优化？请举例说明如何优化查询性能。"><a href="#2、什么是-SQL-查询优化？请举例说明如何优化查询性能。" class="headerlink" title="2、什么是 SQL 查询优化？请举例说明如何优化查询性能。"></a>2、什么是 SQL 查询优化？请举例说明如何优化查询性能。</h4><p><strong>答案：</strong> SQL 查询优化是通过调整查询语句和数据库结构来提高查询性能的过程。</p>
<p>优化查询性能的方法包括：</p>
<ul>
<li><p>避免使用 SELECT *，只选择需要的列。</p>
</li>
<li><p>使用合适的索引：为经常用于查询的列创建索引，避免全表扫描。</p>
</li>
<li><p>缓存重复查询结果：使用缓存技术，避免重复执行相同的查询。</p>
</li>
<li><p>优化查询语句：避免使用不必要的 JOIN 操作，合理使用 WHERE 子句和 LIMIT 限制结果集大小等。</p>
</li>
<li><p>对查询进行分析，使用 EXPLAIN 关键字查看查询执行计划，并进行必要的优化。</p>
</li>
</ul>
<h4 id="3、什么是数据库的事务？如何确保事务的原子性？"><a href="#3、什么是数据库的事务？如何确保事务的原子性？" class="headerlink" title="3、什么是数据库的事务？如何确保事务的原子性？"></a>3、什么是数据库的事务？如何确保事务的原子性？</h4><p><strong>答案：</strong> 事务是一组被视为单个逻辑单元的操作，要么全部执行成功，要么全部回滚。事务的原子性是通过将操作封装在 BEGIN、COMMIT 和 ROLLBACK 语句中来实现的。BEGIN 表示事务的开始，COMMIT 表示事务的提交，而 ROLLBACK 表示事务的回滚。</p>
<h4 id="4、什么是数据库事务的隔离级别？请列举不同的隔离级别。"><a href="#4、什么是数据库事务的隔离级别？请列举不同的隔离级别。" class="headerlink" title="4、什么是数据库事务的隔离级别？请列举不同的隔离级别。"></a>4、什么是数据库事务的隔离级别？请列举不同的隔离级别。</h4><p><strong>答案：</strong> 数据库事务的隔离级别定义了多个事务之间的可见性和并发性。</p>
<p>常见的隔离级别包括：</p>
<ul>
<li><p>读未提交（Read Uncommitted）：一个事务可以读取另一个事务未提交的数据。</p>
</li>
<li><p>读已提交（Read Committed）：一个事务只能读取另一个事务已提交的数据。</p>
</li>
<li><p>可重复读（Repeatable Read）：在同一个事务中，多次读取同一数据的结果是一致的，即使其他事务对该数据进行了修改。</p>
</li>
<li><p>串行化（Serializable）：事务之间完全隔离，每个事务按顺序执行。</p>
</li>
</ul>
<h4 id="5、请解释什么是数据库连接池，以及其作用是什么？"><a href="#5、请解释什么是数据库连接池，以及其作用是什么？" class="headerlink" title="5、请解释什么是数据库连接池，以及其作用是什么？"></a>5、请解释什么是数据库连接池，以及其作用是什么？</h4><p><strong>答案：</strong> 数据库连接池是一个管理数据库连接的缓冲池。它的作用是在应用程序和数据库之间建立和复用数据库连接，以提高性能和可伸缩性。连接池会预先创建一定数量的数据库连接，并将它们保存在池中，当应用程序需要连接数据库时，从池中获取一个连接，并在使用完毕后将连接返回到池中，以便其他应用程序可以复用。</p>
<h4 id="6、什么是数据库事务的并发控制？请解释并发控制中的锁和事务隔离的关系。"><a href="#6、什么是数据库事务的并发控制？请解释并发控制中的锁和事务隔离的关系。" class="headerlink" title="6、什么是数据库事务的并发控制？请解释并发控制中的锁和事务隔离的关系。"></a>6、什么是数据库事务的并发控制？请解释并发控制中的锁和事务隔离的关系。</h4><p><strong>答案：</strong> 并发控制是指在多个事务并发执行时，保证数据一致性和事务隔离的机制。锁是并发控制的一种常见手段，用于对数据库中的数据进行访问控制。事务隔离级别定义了事务之间的可见性和并发性，通过锁机制可以实现不同隔离级别的并发控制。</p>
<h4 id="7、请解释什么是数据库的锁，以及常见的锁类型。"><a href="#7、请解释什么是数据库的锁，以及常见的锁类型。" class="headerlink" title="7、请解释什么是数据库的锁，以及常见的锁类型。"></a>7、请解释什么是数据库的锁，以及常见的锁类型。</h4><p><strong>答案：</strong> 数据库的锁是用于控制并发访问的机制，以保证事务的隔离性和数据的完整性。</p>
<p>常见的锁类型包括：</p>
<ul>
<li><p>共享锁（Shared Lock）：多个事务可以同时获取共享锁，用于读取数据，但不允许其他事务修改数据。</p>
</li>
<li><p>排他锁（Exclusive Lock）：只允许一个事务获取排他锁，用于修改数据，其他事务无法同时获取共享锁或排他锁。</p>
</li>
<li><p>行锁（Row Lock）：锁定数据库表中的某行数据，用于控制对特定行的访问。</p>
</li>
<li><p>表锁（Table Lock）：锁定整个数据库表，用于控制对整个表的访问。</p>
</li>
</ul>
<h4 id="8、如何处理并发事务冲突？请介绍一下悲观锁和乐观锁的原理和应用场景。"><a href="#8、如何处理并发事务冲突？请介绍一下悲观锁和乐观锁的原理和应用场景。" class="headerlink" title="8、如何处理并发事务冲突？请介绍一下悲观锁和乐观锁的原理和应用场景。"></a>8、如何处理并发事务冲突？请介绍一下悲观锁和乐观锁的原理和应用场景。</h4><p><strong>答案：</strong> 并发事务冲突是指多个事务同时访问和修改相同的数据时可能导致的数据一致性问题。处理并发事务冲突常用的方式包括悲观锁和乐观锁。</p>
<ul>
<li><p>悲观锁：在执行读写操作之前，悲观锁会对数据加锁，阻止其他事务对数据的修改。常见的悲观锁实现方式是通过数据库的行级锁或表级锁来实现。悲观锁适用于并发写入较多的场景，但可能导致性能下降和锁竞争问题。</p>
</li>
<li><p>乐观锁：乐观锁假设事务之间不会发生冲突，不会主动加锁，而是在提交事务时检查数据是否被其他事务修改过。常见的乐观锁实现方式是使用版本号或时间戳来检测数据的并发修改。乐观锁适用于并发读取较多、冲突较少的场景，可以减少锁竞争和性能开销。</p>
</li>
</ul>
<h4 id="9、请解释什么是分库分表，并说明其优缺点。"><a href="#9、请解释什么是分库分表，并说明其优缺点。" class="headerlink" title="9、请解释什么是分库分表，并说明其优缺点。"></a>9、请解释什么是分库分表，并说明其优缺点。</h4><p><strong>答案：</strong> 分库分表是将一个大型数据库拆分成多个小型数据库或表，以提高数据库的扩展性和性能。</p>
<p>优点包括：</p>
<ul>
<li><p>提高读写性能：分库分表可以将负载分散到多个数据库或表上，提高并发处理能力。</p>
</li>
<li><p>提高可用性：当部分数据库或表发生故障时，其他数据库或表仍然可用。</p>
</li>
</ul>
<p>缺点包括：</p>
<ul>
<li><p>数据一致性：跨库事务管理和数据同步变得更加复杂。</p>
</li>
<li><p>查询复杂性：涉及多个数据库或表的查询需要进行联合查询或分布式查询。</p>
</li>
</ul>
<h4 id="10、请解释什么是聚集索引和非聚集索引，并描述它们之间的区别。"><a href="#10、请解释什么是聚集索引和非聚集索引，并描述它们之间的区别。" class="headerlink" title="10、请解释什么是聚集索引和非聚集索引，并描述它们之间的区别。"></a>10、请解释什么是聚集索引和非聚集索引，并描述它们之间的区别。</h4><p><strong>答案：</strong> 聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）是 MySQL 数据库中常见的两种索引类型，它们在物理存储和数据访问方面有所不同。</p>
<p>聚集索引：</p>
<ul>
<li>聚集索引定义了表的物理排序顺序，决定了数据行在磁盘上的存储位置。</li>
<li>一个表只能拥有一个聚集索引，通常是主键索引。</li>
<li>聚集索引的叶子节点包含了完整的数据行，因此可以满足覆盖索引的查询需求。</li>
<li>由于数据行按聚集索引的顺序进行物理存储，所以聚集索引对于范围查询和排序操作的性能影响较大。</li>
</ul>
<p>非聚集索引：</p>
<ul>
<li>非聚集索引是基于表中的某个列或多个列创建的索引，与实际数据行的物理存储顺序无关。</li>
<li>一个表可以拥有多个非聚集索引。</li>
<li>非聚集索引的叶子节点包含了索引列的值以及指向对应数据行的指针。</li>
<li>当使用非聚集索引进行查询时，需要通过索引找到对应的行指针，然后再根据指针找到实际的数据行，因此需要进行两次查找操作。</li>
<li>非聚集索引适合于快速定位数据行的查询，但在范围查询和排序操作上的性能可能相对较差。</li>
</ul>
<p>总结：</p>
<p>聚集索引决定了表中数据行的物理存储顺序，可以满足覆盖索引的查询需求，适合范围查询和排序操作；而非聚集索引是基于表中列的值创建的索引，需要进行两次查找操作，适合快速定位数据行的查询。</p>
<h3 id="四、熟悉常用的-Java-Web-开发框架的使用，如-Spring、Spring-MVC、MyBatis、Spring-Boot-等，理解-IOC、AOP-原理，了解-Spring-MVC-的工作流程和-Spring-Boot-的启动过程、自动装配原理。"><a href="#四、熟悉常用的-Java-Web-开发框架的使用，如-Spring、Spring-MVC、MyBatis、Spring-Boot-等，理解-IOC、AOP-原理，了解-Spring-MVC-的工作流程和-Spring-Boot-的启动过程、自动装配原理。" class="headerlink" title="四、熟悉常用的 Java Web 开发框架的使用，如 Spring、Spring MVC、MyBatis、Spring Boot 等，理解 IOC、AOP 原理，了解 Spring MVC 的工作流程和 Spring Boot 的启动过程、自动装配原理。"></a>四、熟悉常用的 Java Web 开发框架的使用，如 Spring、Spring MVC、MyBatis、Spring Boot 等，理解 IOC、AOP 原理，了解 Spring MVC 的工作流程和 Spring Boot 的启动过程、自动装配原理。</h3><h4 id="1、什么是-IOC（控制反转）和-DI（依赖注入）？它们在-Spring-框架中有何作用？"><a href="#1、什么是-IOC（控制反转）和-DI（依赖注入）？它们在-Spring-框架中有何作用？" class="headerlink" title="1、什么是 IOC（控制反转）和 DI（依赖注入）？它们在 Spring 框架中有何作用？"></a>1、什么是 IOC（控制反转）和 DI（依赖注入）？它们在 Spring 框架中有何作用？</h4><p><strong>答案：</strong> IOC 是一种设计模式，它将对象的创建和对象之间的依赖关系的管理交给了容器。DI 是 IOC 的一种实现方式，通过注入依赖对象来实现对象之间的解耦。在 Spring 框架中，IOC 和 DI 使得开发者可以更好地管理对象的创建和依赖关系，提高了代码的可维护性和可测试性。</p>
<h4 id="2、请简要介绍一下-Spring-框架中的-AOP（面向切面编程）。"><a href="#2、请简要介绍一下-Spring-框架中的-AOP（面向切面编程）。" class="headerlink" title="2、请简要介绍一下 Spring 框架中的 AOP（面向切面编程）。"></a>2、请简要介绍一下 Spring 框架中的 AOP（面向切面编程）。</h4><p><strong>答案：</strong> AOP 是一种编程范式，它通过将横切逻辑（如日志记录、事务管理等）与业务逻辑分离，使得代码的重用性和可维护性得到提高。在 Spring 框架中，AOP 通过使用代理对象对目标对象进行包装，实现了在目标对象的方法执行前、执行后或异常抛出时插入横切逻辑的功能。</p>
<h4 id="3、Spring-中的-Bean-作用域有哪些？它们的区别是什么？"><a href="#3、Spring-中的-Bean-作用域有哪些？它们的区别是什么？" class="headerlink" title="3、Spring 中的 Bean 作用域有哪些？它们的区别是什么？"></a>3、Spring 中的 Bean 作用域有哪些？它们的区别是什么？</h4><p><strong>答案：</strong> Spring 框架中的 Bean 作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）和全局会话（Global Session）等。</p>
<p>它们的区别如下：</p>
<ul>
<li><p>单例：在整个应用程序中只创建一个 Bean 实例。</p>
</li>
<li><p>原型：每次请求时创建一个新的 Bean 实例。</p>
</li>
<li><p>会话：在 Web 应用中，为每个会话创建一个 Bean 实例。</p>
</li>
<li><p>请求：在 Web 应用中，为每个请求创建一个 Bean 实例。</p>
</li>
<li><p>全局会话：在基于 Portlet 的 Web 应用中，为每个全局会话创建一个 Bean 实例。</p>
</li>
</ul>
<h4 id="4、Spring-框架中的-Bean-生命周期是怎样的？"><a href="#4、Spring-框架中的-Bean-生命周期是怎样的？" class="headerlink" title="4、Spring 框架中的 Bean 生命周期是怎样的？"></a>4、Spring 框架中的 Bean 生命周期是怎样的？</h4><p><strong>答案：</strong> Spring 框架中的 Bean 生命周期包括以下阶段：</p>
<ol>
<li><p>实例化：根据 Bean 的定义，创建 Bean 的实例。</p>
</li>
<li><p>属性赋值：将配置的属性值或引用注入到 Bean 实例中。</p>
</li>
<li><p>初始化：执行自定义的初始化逻辑，可以实现 InitializingBean 接口或添加自定义的初始化方法。</p>
</li>
<li><p>使用：Bean 实例可供其他组件使用。</p>
</li>
<li><p>销毁：执行自定义的销毁逻辑，可以实现 DisposableBean 接口或添加自定义的销毁方法。</p>
</li>
</ol>
<h4 id="5、如何解决-Spring-框架中的循环依赖问题？"><a href="#5、如何解决-Spring-框架中的循环依赖问题？" class="headerlink" title="5、如何解决 Spring 框架中的循环依赖问题？"></a>5、如何解决 Spring 框架中的循环依赖问题？</h4><p><strong>答案：</strong> Spring 框架通过三级缓存解决循环依赖问题。当创建 Bean 时，Spring 会将正在创建的 Bean 放入“当前创建 Bean”缓存中，然后继续创建 Bean 的属性依赖。如果遇到循环依赖，Spring 会将正在创建 Bean 的 ObjectFactory 放入“早期暴露 Bean”缓存中，以供循环依赖的 Bean 使用。最后，当 Bean 创建完成后，Spring 会将其放入“已完成 Bean”缓存中，以供后续的 Bean 依赖使用。</p>
<h4 id="6、Spring-框架中的事务管理是如何实现的？"><a href="#6、Spring-框架中的事务管理是如何实现的？" class="headerlink" title="6、Spring 框架中的事务管理是如何实现的？"></a>6、Spring 框架中的事务管理是如何实现的？</h4><p><strong>答案：</strong> Spring 框架中的事务管理通过 AOP 实现。在 Spring 中，可以通过声明式事务管理和编程式事务管理两种方式来管理事务。声明式事务管理通过在方法上添加事务注解（如@Transactional）来定义事务的边界，Spring 会在方法执行前后自动管理事务的开启、提交和回滚。编程式事务管理则通过编写代码来手动管理事务的开启、提交和回滚。</p>
<h4 id="7、Spring-MVC-的工作流程是怎样的？"><a href="#7、Spring-MVC-的工作流程是怎样的？" class="headerlink" title="7、Spring MVC 的工作流程是怎样的？"></a>7、Spring MVC 的工作流程是怎样的？</h4><p><strong>答案：</strong> Spring MVC 的工作流程如下：</p>
<ol>
<li><p>客户端发送请求到 DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet 根据请求的 URL 找到对应的 HandlerMapping，确定请求对应的 Controller。</p>
</li>
<li><p>Controller 处理请求，并返回一个 ModelAndView 对象。</p>
</li>
<li><p>DispatcherServlet 通过 ViewResolver 解析 ModelAndView 中的 View 名字，得到具体的 View 对象。</p>
</li>
<li><p>View 对象负责渲染 Model 数据，并生成最终的响应结果。</p>
</li>
<li><p>DispatcherServlet 将响应结果返回给客户端。</p>
</li>
</ol>
<h4 id="8、MyBatis-的工作原理是什么？MyBatis-中-和-的区别？"><a href="#8、MyBatis-的工作原理是什么？MyBatis-中-和-的区别？" class="headerlink" title="8、MyBatis 的工作原理是什么？MyBatis 中 #{} 和 ${} 的区别？"></a>8、MyBatis 的工作原理是什么？MyBatis 中 #{} 和 ${} 的区别？</h4><p><strong>答案：</strong> MyBatis 是一种 Java 持久化框架，用于简化数据库访问的过程。它提供了一个基于映射的方式来执行 SQL 查询、插入、更新和删除等操作。</p>
<p>MyBatis 的工作原理:</p>
<ol>
<li><p>配置文件(mybatis-config.xml)来描述如何连接数据库，如何获得 SqlSession 实例等。</p>
</li>
<li><p>定义 SQL 映射文件，将 SQL 语句与 bean 类或某个接口进行映射。</p>
</li>
<li><p>根据配置文件获取 SqlSession 实例，执行映射文件中定义的 SQL 语句。</p>
</li>
<li><p>使用动态代理实现接口返回结果集</p>
</li>
</ol>
<p>#{} 和 ${} 的区别:</p>
<ul>
<li><p>#{} 表示一个参数，MyBatis 会根据 PreparedStatement 设置该参数，有防 SQL 注入的好处。</p>
</li>
<li><p>${} 直接将参数填充在 SQL 语句中，可能存在 SQL 注入风险。${} 一般用在空值或其他非输入值的字段上，如写 SQL 时使用分表等。</p>
</li>
</ul>
<p>总之：#{}可以有效预防 SQL 注入，应该尽量使用#{}。${}不可以有效预防 SQL 注入，只适合某些非输入值的特殊场景使用。</p>
<h4 id="9、Spring-Boot-的启动过程是怎样的？"><a href="#9、Spring-Boot-的启动过程是怎样的？" class="headerlink" title="9、Spring Boot 的启动过程是怎样的？"></a>9、Spring Boot 的启动过程是怎样的？</h4><p><strong>答案：</strong> Spring Boot 的启动过程如下：</p>
<ol>
<li><p>加载 Spring Boot 的核心配置文件，创建并初始化 Spring 应用上下文。</p>
</li>
<li><p>扫描应用程序中的类，识别和注册容器管理的 Bean。</p>
</li>
<li><p>执行各种自动配置，包括加载外部配置文件、创建数据库连接池等。</p>
</li>
<li><p>启动嵌入式的 Web 服务器（如 Tomcat、Jetty 等）。</p>
</li>
<li><p>注册 Servlet、Filter、Listener 等 Web 组件。</p>
</li>
<li><p>执行应用程序的初始化逻辑。</p>
</li>
<li><p>应用程序启动完成，等待处理请求。</p>
</li>
</ol>
<h4 id="10、什么是自动装配？Spring-Boot-框架中有哪些自动装配的方式？"><a href="#10、什么是自动装配？Spring-Boot-框架中有哪些自动装配的方式？" class="headerlink" title="10、什么是自动装配？Spring Boot 框架中有哪些自动装配的方式？"></a>10、什么是自动装配？Spring Boot 框架中有哪些自动装配的方式？</h4><p><strong>答案：</strong> 自动装配（Autosiring）是 Spring 框架中的一个核心功能，它能够根据特定的规则，自动将应用程序中的各个组件（Bean）进行连接和配置，减少了手动配置的工作量，提高了开发效率。</p>
<p>在 Spring Boot 框架中，有以下几种自动装配的方式：</p>
<ul>
<li><p><strong>组件扫描（Component Scanning）</strong>：Spring Boot 通过组件扫描机制自动发现应用程序中的组件。可以使用<code>@ComponentScan</code>注解指定要扫描的包路径，Spring Boot 会自动将带有<code>@Component</code>及其派生注解的类注册为 Bean。</p>
</li>
<li><p><strong>条件装配（Conditional Configuration）</strong>：Spring Boot 提供了条件装配的功能，可以根据特定的条件决定是否配置某个 Bean。可以使用<code>@Conditional</code>注解及其派生注解在配置类或 Bean 上设置条件，当条件满足时，相应的 Bean 会被自动装配。</p>
</li>
<li><p><strong>自动配置（Auto-Configuration）</strong>：Spring Boot 提供了大量的自动配置类，根据应用程序的依赖和配置，自动配置框架中的各种组件。自动配置类通常使用<code>@Configuration</code>注解进行标记，通过条件装配来决定是否生效。</p>
</li>
<li><p><strong>自动装配（Autowiring）</strong>：Spring Boot 支持自动装配，即根据类型和名称自动将依赖注入到 Bean 中。可以使用<code>@Autowired</code>注解将需要的依赖注入到 Bean 中，Spring Boot 会自动寻找合适的候选 Bean 进行注入。</p>
</li>
<li><p><strong>属性注入（Property Injection）</strong>：Spring Boot 可以自动将配置文件中的属性值注入到 Bean 的属性中。可以使用<code>@Value</code>注解将属性与配置文件中的属性值进行绑定，Spring Boot 会自动加载配置文件，并将属性值注入到相应的 Bean 中。</p>
</li>
</ul>
<p>这些自动装配的方式使得 Spring Boot 应用程序的开发更加便捷，可以减少冗余的配置代码，提高开发效率。</p>
<h3 id="五、了解微服务架构和分布式系统的基本概念，如-Nacos-注册与配置、Gateway-网关、OpenFeign-服务调用等。"><a href="#五、了解微服务架构和分布式系统的基本概念，如-Nacos-注册与配置、Gateway-网关、OpenFeign-服务调用等。" class="headerlink" title="五、了解微服务架构和分布式系统的基本概念，如 Nacos 注册与配置、Gateway 网关、OpenFeign 服务调用等。"></a>五、了解微服务架构和分布式系统的基本概念，如 Nacos 注册与配置、Gateway 网关、OpenFeign 服务调用等。</h3><h4 id="1、什么是微服务架构？它的优势和劣势是什么？"><a href="#1、什么是微服务架构？它的优势和劣势是什么？" class="headerlink" title="1、什么是微服务架构？它的优势和劣势是什么？"></a>1、什么是微服务架构？它的优势和劣势是什么？</h4><p><strong>答案：</strong> 微服务架构是一种将应用程序拆分为一组小型、松耦合的服务的方法。每个服务都可以独立部署、扩展和管理。优势包括提高系统的可扩展性、可维护性和灵活性，允许团队使用不同的技术栈和开发周期。劣势包括增加了系统的复杂性、部署和监控的挑战，以及在跨服务的通信和一致性处理方面的复杂性。</p>
<h4 id="2、Nacos-是什么？它在微服务架构中的作用是什么？"><a href="#2、Nacos-是什么？它在微服务架构中的作用是什么？" class="headerlink" title="2、Nacos 是什么？它在微服务架构中的作用是什么？"></a>2、Nacos 是什么？它在微服务架构中的作用是什么？</h4><p><strong>答案：</strong> Nacos 是一个用于动态服务发现、配置管理和服务治理的开源平台。它提供了服务注册与发现、动态配置管理、服务健康监测等功能。在微服务架构中，Nacos 可以用作服务注册中心，让服务实例能够注册自己的信息并让其他服务发现并调用它们。</p>
<h4 id="3、什么是-Gateway-网关？它的作用是什么？"><a href="#3、什么是-Gateway-网关？它的作用是什么？" class="headerlink" title="3、什么是 Gateway 网关？它的作用是什么？"></a>3、什么是 Gateway 网关？它的作用是什么？</h4><p><strong>答案：</strong> Gateway 网关是微服务架构中的一种设计模式，它充当了服务的入口，负责将外部请求路由到相应的微服务实例。它可以处理认证、授权、限流、负载均衡等功能，同时也可以提供统一的 API 接口给客户端使用。Gateway 网关可以起到保护微服务免受恶意请求和异常流量的作用。</p>
<h4 id="4、请解释一下-OpenFeign-在微服务架构中的作用。"><a href="#4、请解释一下-OpenFeign-在微服务架构中的作用。" class="headerlink" title="4、请解释一下 OpenFeign 在微服务架构中的作用。"></a>4、请解释一下 OpenFeign 在微服务架构中的作用。</h4><p><strong>答案：</strong> OpenFeign 是一个用于声明式、模板化的 HTTP 客户端工具，它简化了在微服务架构中进行服务间通信的开发过程。通过使用注解和接口定义，开发人员可以轻松地声明需要调用的远程服务，并使用类似于本地方法调用的方式进行调用，而无需手动处理底层的 HTTP 请求和序列化。</p>
<h4 id="5、你了解哪些微服务架构中的负载均衡策略？"><a href="#5、你了解哪些微服务架构中的负载均衡策略？" class="headerlink" title="5、你了解哪些微服务架构中的负载均衡策略？"></a>5、你了解哪些微服务架构中的负载均衡策略？</h4><p><strong>答案：</strong> 在微服务架构中，有几种常见的负载均衡策略。</p>
<p>以下是其中一些常见的策略：</p>
<ul>
<li><p>轮询（Round Robin）：将请求依次分发给可用的服务实例。每个请求按顺序选择下一个服务实例，直到循环到第一个实例。</p>
</li>
<li><p>随机（Random）：随机选择可用的服务实例来处理请求。每个请求都会随机选择一个服务实例，没有特定的顺序。</p>
</li>
<li><p>最少连接（Least Connection）：选择当前连接数最少的服务实例来处理请求。这种策略考虑了每个服务实例的负载情况，将请求分发给连接数最少的实例，以实现负载均衡。</p>
</li>
<li><p>IP 哈希（IP Hash）：根据客户端的 IP 地址将请求路由到特定的服务实例。使用客户端的 IP 地址计算哈希值，然后将请求发送到对应哈希值的服务实例。</p>
</li>
<li><p>加权轮询（Weighted Round Robin）：为每个服务实例分配一个权重值，权重值越高的实例，接收到的请求比例就越大。这种策略可以根据服务实例的处理能力和性能分配不同的权重。</p>
</li>
<li><p>加权随机（Weighted Random）：类似于加权轮询，但是选择服务实例的方式是随机的。每个实例的选择概率与其权重成比例。</p>
</li>
<li><p>一致性哈希（Consistent Hashing）：通过哈希算法将请求映射到服务实例。这种策略可以在添加或删除服务实例时最小化请求的重新分配，因为只有少量的请求会受到影响。</p>
</li>
</ul>
<p>这些负载均衡策略可以根据具体的需求和环境选择适合的策略，以实现在微服务架构中的负载均衡和性能优化。</p>
<h4 id="6、在微服务架构中，如何保证数据的一致性？"><a href="#6、在微服务架构中，如何保证数据的一致性？" class="headerlink" title="6、在微服务架构中，如何保证数据的一致性？"></a>6、在微服务架构中，如何保证数据的一致性？</h4><p><strong>答案：</strong> 在微服务架构中，确保数据的一致性是一个具有挑战性的任务，因为数据可能分布在不同的服务中，并且每个服务都有自己的数据库或数据存储。</p>
<p>下面是两个常用的方法来保证数据的一致性：</p>
<ul>
<li><p><strong>事件驱动架构（Event-Driven Architecture）</strong>：事件驱动架构是一种常见的解决方案，它通过在服务之间发送和接收事件来实现数据的一致性。当一个服务的数据发生变化时，它会发布一个事件，其他服务可以订阅这个事件并采取相应的操作来保持数据的一致性。例如，当一个订单服务接收到一个新订单时，它可以发布一个“订单创建”事件，其他服务，如库存服务和支付服务可以通过订阅这个事件来更新库存和执行支付操作。通过事件驱动架构，各个服务之间的数据变更可以异步地进行，从而提高了系统的可伸缩性和灵活性。</p>
</li>
<li><p><strong>分布式事务（Distributed Transactions）</strong>：分布式事务是另一种保证数据一致性的常见方法。它通过将多个操作组合为一个原子操作来确保数据的一致性。当一个跨多个服务的操作需要保证一致性时，可以使用分布式事务来协调这些服务的操作。分布式事务使用了一致性协议，如两阶段提交（Two-Phase Commit）或三阶段提交（Three-Phase Commit），来确保所有参与者在提交或回滚操作时达成一致的状态。这种方法可以保证在跨多个服务的操作中，要么所有的操作都成功提交，要么所有的操作都回滚，从而保持数据的一致性。</p>
</li>
</ul>
<p>这些方法都有各自的优势和限制，选择合适的方法取决于具体的业务需求和系统架构。在实践中，通常会根据具体情况综合使用多种方法来保证数据的一致性。</p>
<h4 id="7、你知道什么是服务降级吗？它在微服务架构中的作用是什么？"><a href="#7、你知道什么是服务降级吗？它在微服务架构中的作用是什么？" class="headerlink" title="7、你知道什么是服务降级吗？它在微服务架构中的作用是什么？"></a>7、你知道什么是服务降级吗？它在微服务架构中的作用是什么？</h4><p><strong>答案：</strong> 服务降级是一种应对系统故障或高负载情况的策略，当某个微服务出现问题时，可以通过降低其功能或性能来保证整个系统的可用性。服务降级可以通过返回缓存数据、返回默认值、限制请求频率等方式来实现，从而减少对故障服务的依赖。</p>
<h4 id="8、如何处理微服务架构中的服务间通信失败的情况？"><a href="#8、如何处理微服务架构中的服务间通信失败的情况？" class="headerlink" title="8、如何处理微服务架构中的服务间通信失败的情况？"></a>8、如何处理微服务架构中的服务间通信失败的情况？</h4><p><strong>答案：</strong> 在微服务架构中，服务间通信失败是一个常见的情况。</p>
<p>处理这种情况需要考虑以下几个方面：</p>
<ul>
<li><p><strong>重试机制</strong>：当服务间通信失败时，可以通过实施重试机制来尝试重新发送请求。重试可以在服务内部实现，也可以通过使用消息队列来处理。在实施重试机制时，可以设置最大重试次数和重试间隔，以避免无限制地进行重试。</p>
</li>
<li><p><strong>超时处理</strong>：为了防止服务间通信失败导致的长时间阻塞，可以设置超时机制。在发送请求后，如果没有及时收到响应，可以选择中断请求并进行相应的处理，例如记录日志、发送警报或返回适当的错误信息。</p>
</li>
<li><p><strong>熔断机制</strong>：为了防止服务间通信失败引发的级联故障，可以实施熔断机制。熔断机制会监控服务间通信的错误率或响应时间，并在达到一定阈值时中断对该服务的请求。中断后，可以选择返回一个预定义的错误响应，而不是继续请求该服务。</p>
</li>
<li><p><strong>降级处理</strong>：当服务间通信失败时，可以选择降级处理。降级意味着在服务不可用或响应时间过长的情况下，提供一个备用的简化功能。例如，返回缓存数据、使用默认值或提供有限功能的替代服务。</p>
</li>
<li><p><strong>监控和告警</strong>：建立监控系统来实时监测服务间通信的状态和性能，以便及时发现故障并采取措施。同时，设置适当的告警机制，以便在服务间通信失败时及时通知相关团队进行处理。</p>
</li>
<li><p><strong>日志和故障排查</strong>：记录服务间通信的日志，并建立适当的故障排查机制。通过分析日志，可以定位问题的根本原因，并采取措施进行修复或优化。</p>
</li>
</ul>
<p>综上所述，处理微服务架构中的服务间通信失败需要综合考虑重试机制、超时处理、熔断机制、降级处理、监控和告警以及日志和故障排查等策略，以提高系统的可靠性和容错性。</p>
<h4 id="9、你了解微服务架构中的消息队列吗？它有什么作用？"><a href="#9、你了解微服务架构中的消息队列吗？它有什么作用？" class="headerlink" title="9、你了解微服务架构中的消息队列吗？它有什么作用？"></a>9、你了解微服务架构中的消息队列吗？它有什么作用？</h4><p><strong>答案：</strong> 在微服务架构中，消息队列是一种常见的通信模式，用于实现微服务之间的异步通信。它允许一个微服务将消息发送到队列，而不需要直接与接收方进行通信。接收方则可以按照自己的节奏从队列中获取消息并进行处理。</p>
<p>消息队列在微服务架构中具有以下几个主要作用：</p>
<ul>
<li><p>异步通信：消息队列提供了一种异步的通信机制。发送方将消息发送到队列后，可以立即继续处理其他任务，而无需等待接收方的响应。这样可以提高系统的整体性能和吞吐量。</p>
</li>
<li><p>服务解耦：通过使用消息队列，微服务之间的通信变得松耦合。发送方只需要将消息发送到队列中，而不需要知道消息的具体接收方。接收方可以根据自己的需求从队列中订阅感兴趣的消息。这种解耦使得微服务的开发和维护更加灵活和可扩展。</p>
</li>
<li><p>削峰填谷：消息队列可以用于平衡系统中不同微服务之间的负载。当一个微服务处理能力不足以应对突发的高负载时，可以将消息发送到队列中，以便稍后处理。这样可以有效地平衡系统的负载，防止系统崩溃或性能下降。</p>
</li>
<li><p>可靠性保证：消息队列通常提供持久化机制，确保即使在系统故障或重启后，消息也不会丢失。消息可以持久化到磁盘上，以便在系统恢复后重新加载和处理。这提高了系统的可靠性和健壮性。</p>
</li>
<li><p>系统解耦：通过引入消息队列，可以将复杂的系统拆分为多个独立的微服务，每个微服务负责处理特定的业务逻辑。这种解耦使得系统更容易理解、开发和维护。</p>
</li>
</ul>
<p>综上所述，消息队列在微服务架构中发挥着重要的作用，包括实现异步通信、服务解耦、削峰填谷和提供可靠性保证。它是构建可靠、可扩展和高性能微服务系统的重要组成部分。</p>
<h4 id="10、在微服务架构中，如何进行服务监控和日志记录？"><a href="#10、在微服务架构中，如何进行服务监控和日志记录？" class="headerlink" title="10、在微服务架构中，如何进行服务监控和日志记录？"></a>10、在微服务架构中，如何进行服务监控和日志记录？</h4><p><strong>答案：</strong> 微服务架构中的服务监控和日志记录非常重要。可以使用监控工具（如 Prometheus、Grafana）来收集和展示服务的运行指标，以便及时发现和解决问题。同时，使用日志记录框架（如 ELK Stack、Sleuth+Zipkin）可以帮助收集、存储和分析微服务的日志信息，以便进行故障排查和性能优化。</p>
<h3 id="六、了解-Redis-缓存的使用，如数据存储、缓存策略、哨兵机制、发布订阅功能以及应对缓存雪崩等。"><a href="#六、了解-Redis-缓存的使用，如数据存储、缓存策略、哨兵机制、发布订阅功能以及应对缓存雪崩等。" class="headerlink" title="六、了解 Redis 缓存的使用，如数据存储、缓存策略、哨兵机制、发布订阅功能以及应对缓存雪崩等。"></a>六、了解 Redis 缓存的使用，如数据存储、缓存策略、哨兵机制、发布订阅功能以及应对缓存雪崩等。</h3><h4 id="1、什么是-Redis？它的主要特点是什么？Redis-与传统关系型数据库的区别是什么？"><a href="#1、什么是-Redis？它的主要特点是什么？Redis-与传统关系型数据库的区别是什么？" class="headerlink" title="1、什么是 Redis？它的主要特点是什么？Redis 与传统关系型数据库的区别是什么？"></a>1、什么是 Redis？它的主要特点是什么？Redis 与传统关系型数据库的区别是什么？</h4><p><strong>答案：</strong> Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，它提供了键值对的存储，并支持多种数据结构。</p>
<p>Redis 具有以下主要特点：</p>
<ul>
<li><p>数据存储在内存中，因此读写速度非常快。</p>
</li>
<li><p>支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等。</p>
</li>
<li><p>提供了丰富的功能，如事务、持久化、发布订阅等。</p>
</li>
<li><p>可以通过主从复制和哨兵机制实现高可用性。</p>
</li>
</ul>
<p>Redis 和传统关系型数据库有以下几个主要区别：</p>
<ul>
<li><p>存储方式：Redis 将数据存储在内存中，而传统关系型数据库通常将数据存储在磁盘上。</p>
</li>
<li><p>数据结构：Redis 支持多种数据结构，如字符串、哈希、列表等，而关系型数据库使用表和行来组织数据。</p>
</li>
<li><p>查询语言：Redis 使用类似于键值对的 API 进行数据访问，而关系型数据库使用 SQL 查询语言。</p>
</li>
<li><p>持久化：Redis 可以选择将数据持久化到磁盘上，但默认情况下只将数据存储在内存中，而关系型数据库通常将数据持久化到磁盘上。</p>
</li>
</ul>
<h4 id="2、Redis-的持久化机制有哪些？它们有什么区别？"><a href="#2、Redis-的持久化机制有哪些？它们有什么区别？" class="headerlink" title="2、Redis 的持久化机制有哪些？它们有什么区别？"></a>2、Redis 的持久化机制有哪些？它们有什么区别？</h4><p><strong>答案：</strong> Redis 提供了两种持久化机制：</p>
<ul>
<li><p>RDB（Redis Database）：将 Redis 在内存中的数据定期保存到磁盘上的二进制文件。RDB 是一个快照（snapshot）的形式，保存了某个时间点上的数据快照。它适用于数据比较稳定，可以容忍一定数据丢失的场景。</p>
</li>
<li><p>AOF（Append-Only File）：将 Redis 的操作日志以追加的方式写入磁盘文件。AOF 记录了 Redis 的所有写操作指令，通过重放这些指令可以恢复数据。AOF 适用于需要高数据安全性和可靠性的场景。</p>
</li>
</ul>
<p>RDB 持久化方式相对于 AOF 方式更加高效，因为它只需要保存一个快照文件，而 AOF 方式需要记录每条写操作指令。但是 AOF 方式更加安全，因为可以通过重放操作日志来恢复数据，并且可以配置不同级别的同步策略来控制数据的安全性和性能。</p>
<h4 id="3、Redis-的主从复制是什么？它的作用是什么？"><a href="#3、Redis-的主从复制是什么？它的作用是什么？" class="headerlink" title="3、Redis 的主从复制是什么？它的作用是什么？"></a>3、Redis 的主从复制是什么？它的作用是什么？</h4><p><strong>答案：</strong> Redis 的主从复制是指将一个 Redis 节点（主节点）的数据复制到其他 Redis 节点（从节点）的过程，从节点会持续地复制主节点上的数据更新操作，以保持数据的一致性。</p>
<p>主从复制的作用包括：</p>
<ul>
<li><p>提高读性能：主从复制可以使得读操作分摊到多个节点上，从而提高整体的读性能。</p>
</li>
<li><p>数据备份：从节点可以作为主节点数据的备份，当主节点发生故障时，可以快速切换到从节点继续提供服务。</p>
</li>
<li><p>扩展性：通过添加多个从节点，可以扩展系统的读能力，满足高并发读取的需求。</p>
</li>
</ul>
<h4 id="4、Redis-的缓存策略有哪些？请分别说明它们的特点。"><a href="#4、Redis-的缓存策略有哪些？请分别说明它们的特点。" class="headerlink" title="4、Redis 的缓存策略有哪些？请分别说明它们的特点。"></a>4、Redis 的缓存策略有哪些？请分别说明它们的特点。</h4><p><strong>答案：</strong> Redis 的常见缓存策略包括：</p>
<ul>
<li><p>LRU（Least Recently Used）：最近最少使用策略，淘汰最近使用次数最少的数据。</p>
</li>
<li><p>LFU（Least Frequently Used）：最不经常使用策略，淘汰使用频率最低的数据。</p>
</li>
<li><p>TTL（Time To Live）：设置数据的过期时间，过期后自动删除。</p>
</li>
<li><p>Random（随机）：随机选择要淘汰的数据。</p>
</li>
</ul>
<p>LRU 和 LFU 是基于数据的访问频率来确定淘汰策略的，TTL 是基于数据的过期时间来淘汰数据的，而随机策略则是随机选择要淘汰的数据，没有特定的规则。</p>
<h4 id="5、Redis-的哨兵机制是什么？它的作用是什么？"><a href="#5、Redis-的哨兵机制是什么？它的作用是什么？" class="headerlink" title="5、Redis 的哨兵机制是什么？它的作用是什么？"></a>5、Redis 的哨兵机制是什么？它的作用是什么？</h4><p><strong>答案：</strong> Redis 的哨兵机制是一种用于监控和管理 Redis 主从复制和高可用性的解决方案。哨兵是一个独立的进程，负责监控 Redis 实例的状态，并在主节点下线时自动将一个从节点升级为新的主节点。</p>
<p>哨兵的主要作用包括：</p>
<ul>
<li><p>监控：哨兵定期检查 Redis 实例的状态，包括主节点和从节点是否正常运行。</p>
</li>
<li><p>自动故障转移：当主节点宕机时，哨兵会自动将一个从节点升级为新的主节点，确保系统的高可用性。</p>
</li>
<li><p>配置提供：哨兵负责维护 Redis 实例的配置信息，如果配置发生变化，哨兵会通知客户端进行更新。</p>
</li>
</ul>
<h4 id="6、Redis-的发布订阅功能是什么？如何使用它？"><a href="#6、Redis-的发布订阅功能是什么？如何使用它？" class="headerlink" title="6、Redis 的发布订阅功能是什么？如何使用它？"></a>6、Redis 的发布订阅功能是什么？如何使用它？</h4><p><strong>答案：</strong> Redis 的发布订阅功能允许客户端订阅一个或多个频道，并接收发布到这些频道的消息。发布者发布消息到指定的频道，订阅者则可以接收到相应的消息。</p>
<p>使用发布订阅功能的步骤如下：</p>
<ul>
<li><p>订阅频道：客户端使用<code>SUBSCRIBE</code>命令来订阅一个或多个频道，例如<code>SUBSCRIBE channel1</code>。</p>
</li>
<li><p>发布消息：发布者使用<code>PUBLISH</code>命令将消息发布到指定的频道，例如<code>PUBLISH channel1 message1</code>。</p>
</li>
<li><p>接收消息：订阅者通过订阅的频道接收到发布者发布的消息。</p>
</li>
</ul>
<p>通过发布订阅功能，可以实现实时的消息传递和事件通知，适用于实时聊天、消息队列等场景。</p>
<h4 id="7、如何应对-Redis-缓存穿透问题？"><a href="#7、如何应对-Redis-缓存穿透问题？" class="headerlink" title="7、如何应对 Redis 缓存穿透问题？"></a>7、如何应对 Redis 缓存穿透问题？</h4><p><strong>答案：</strong> Redis 缓存穿透是指恶意请求或者非法请求查询一个不存在的 Key，导致请求直接访问数据库，造成数据库压力过大。</p>
<p>解决 Redis 缓存穿透问题的方法包括：</p>
<ul>
<li><p>布隆过滤器：使用布隆过滤器判断请求的 Key 是否存在于缓存中或者数据库中，如果不存在，则直接拦截请求，避免对数据库的查询压力。</p>
</li>
<li><p>空值缓存：对于查询数据库结果为空的情况，也将空结果缓存起来，设置一个较短的过期时间，避免重复的查询请求。</p>
</li>
<li><p>热点数据预加载：将热点数据提前加载到缓存中，确保缓存中存在大部分常用的数据，降低缓存穿透的概率。</p>
</li>
</ul>
<h4 id="8、如何应对-Redis-缓存雪崩问题？"><a href="#8、如何应对-Redis-缓存雪崩问题？" class="headerlink" title="8、如何应对 Redis 缓存雪崩问题？"></a>8、如何应对 Redis 缓存雪崩问题？</h4><p><strong>答案：</strong> Redis 缓存雪崩是指在某个时间点，大量的缓存数据同时失效或过期，导致大量的请求直接访问数据库，造成数据库压力过大，甚至崩溃。</p>
<p>应对 Redis 缓存雪崩问题的常见方法包括：</p>
<ul>
<li><p>设置合理的缓存过期时间：通过合理设置缓存数据的过期时间，避免大量缓存同时失效。</p>
</li>
<li><p>使用分布式锁：在缓存失效时，通过分布式锁来控制只有一个请求去重新加载缓存，其他请求等待并使用旧的缓存数据。</p>
</li>
<li><p>增加缓存层：引入多级缓存架构，如本地缓存和分布式缓存的组合，提高系统的容错性和稳定性。</p>
</li>
<li><p>随机过期时间：可以在设置缓存过期时间时引入一个随机值，使得缓存的过期时间分散，避免大量缓存同时失效。</p>
</li>
</ul>
<h4 id="9、如何应对-Redis-缓存击穿问题？"><a href="#9、如何应对-Redis-缓存击穿问题？" class="headerlink" title="9、如何应对 Redis 缓存击穿问题？"></a>9、如何应对 Redis 缓存击穿问题？</h4><p><strong>答案：</strong> Redis 缓存击穿是指在高并发情况下，一个热点数据的缓存过期或失效，导致大量请求直接访问数据库，造成数据库压力过大的情况。</p>
<p>为了应对缓存击穿问题，可以采取以下措施：</p>
<ul>
<li><p>设置热点数据的永不过期：对于一些非常热门的数据，可以将其缓存设置为永不过期，确保热点数据始终存在于缓存中，避免缓存失效导致的击穿问题。</p>
</li>
<li><p>加互斥锁（Mutex Lock）：在缓存失效的时候，通过加互斥锁的方式，保证只有一个线程能够访问数据库，其他线程等待获取锁。当第一个线程从数据库中加载数据后，其他线程可以从缓存中获取数据，避免了对数据库的重复访问。</p>
</li>
<li><p>使用短暂的自动过期时间：在缓存失效后，第一个请求可以触发一个异步任务去更新缓存，而其他请求可以先返回旧的缓存数据。这样可以避免大量请求同时访问数据库，减轻数据库的压力。</p>
</li>
<li><p>布隆过滤器（Bloom Filter）：布隆过滤器是一种高效的数据结构，用来判断一个元素是否存在于集合中。可以将热点数据的键存储在布隆过滤器中，当请求到来时，先通过布隆过滤器快速判断请求的数据是否存在于缓存中，如果不存在，直接返回缓存未命中，避免了对数据库的访问。</p>
</li>
<li><p>缓存预热：在系统启动或低峰期，可以通过预热的方式将一些热点数据提前加载到缓存中，以减少缓存失效时的冷启动问题，降低缓存击穿的概率。</p>
</li>
<li><p>分布式锁：如果系统是分布式部署的，可以使用分布式锁（如基于 Redis 实现的分布式锁）来保证只有一个节点能够更新缓存，其他节点等待获取锁。这样可以避免多个节点同时访问数据库，减少数据库压力。</p>
</li>
</ul>
<p>以上是常见的应对 Redis 缓存击穿问题的策略。根据具体的业务场景和需求，选择合适的策略或者结合多种策略进行综合应对，以提高系统的性能和可靠性。</p>
<h4 id="10、Redis-缓存穿透、缓存雪崩、缓存击穿有什么区别？"><a href="#10、Redis-缓存穿透、缓存雪崩、缓存击穿有什么区别？" class="headerlink" title="10、Redis 缓存穿透、缓存雪崩、缓存击穿有什么区别？"></a>10、Redis 缓存穿透、缓存雪崩、缓存击穿有什么区别？</h4><p>Redis 缓存穿透、缓存雪崩和缓存击穿是三种与缓存相关的常见问题，它们之间有以下区别：</p>
<ol>
<li><p>缓存穿透（Cache Penetration）：<br>缓存穿透指的是在缓存中无法找到所需数据，并且该数据也不存在于后端数据存储（例如数据库）中。这种情况下，每次请求都会穿透缓存层，直接访问后端存储系统，导致缓存无效，增加了后端负载。通常是由于恶意请求或者查询不存在的数据引起的。</p>
<p>解决方案：</p>
<ul>
<li><p>布隆过滤器（Bloom Filter）：在缓存层之前使用布隆过滤器过滤掉不存在的数据。</p>
</li>
<li><p>缓存空对象（Cache Null Object）：对于查询结果为空的请求，也将空对象缓存起来，避免多次访问后端存储系统。</p>
</li>
</ul>
</li>
<li><p>缓存雪崩（Cache Avalanche）：<br>缓存雪崩指的是在某个时间点，大量的缓存失效，导致大量的请求直接访问后端存储系统，给后端系统带来极大的压力。通常是由于缓存项同时失效，或者在同一时间段内集中大量请求导致的。</p>
<p>解决方案：</p>
<ul>
<li><p>设置合理的过期时间：将缓存的过期时间分散开，避免大量缓存同时失效。</p>
</li>
<li><p>使用多级缓存：将请求分散到不同的缓存层，减少单一缓存层的负载压力。</p>
</li>
<li><p>限流和熔断：控制请求的并发量，避免系统超负荷运行。</p>
</li>
</ul>
</li>
<li><p>缓存击穿（Cache Breakdown）：<br>缓存击穿指的是一个热点数据的缓存失效，导致大量的请求同时访问后端存储系统，增加了后端负载。与缓存雪崩不同的是，缓存击穿只有少数几个缓存项失效，而不是全部。</p>
<p>解决方案：</p>
<ul>
<li><p>加锁和并发控制：使用互斥锁（如分布式锁）来保证只有一个线程去加载数据到缓存，其他线程等待。</p>
</li>
<li><p>提前加载热点数据：针对热点数据，可以提前进行预加载，避免在缓存失效时大量请求同时访问后端存储系统。</p>
</li>
<li><p>热点数据永不过期：对于热点数据，可以将其缓存设置为永不过期，确保始终可用。</p>
</li>
</ul>
</li>
</ol>
<p>总结：</p>
<p>缓存穿透是指查询不存在的数据，导致每次请求都穿透缓存访问后端存储系统；缓存雪崩是指大量缓存同时失效，导致请求直接访问后端存储系统；缓存击穿是指一个热点数据的缓存失效，导致大量请求同时访问后端存储系统。针对这些问题，可以采取不同的解决方案来提高系统的稳定性和性能。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-SpringIOC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/11/07/SpringIOC/" class="article-date">
  	<time datetime="2024-11-07T02:57:58.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/11/07/SpringIOC/">
        &#39;SpringIOC&#39;
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><h2 id="IOC-原理"><a href="#IOC-原理" class="headerlink" title="IOC 原理"></a>IOC 原理</h2><h3 id="代码耦合"><a href="#代码耦合" class="headerlink" title="代码耦合"></a>代码耦合</h3><p>实际开发中，我们如果在对象 A 内部去创建、修改或者注销另一个对象 B，这会导致对象之间非常复杂的依赖关系，不利于代码的维护更新。</p>
<p>比如我们直接在上层类内调用了底层类的构造方法，一旦底层类的构造方法发生改变，就必须修改所有上层类的代码。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>( Dependency Injection ) 我们用依赖注入的方式来降低耦合度。所谓依赖注入，就是把底层对象作为参数传入上层对象。避免底层类被修改后上层类代码也要随之改动。我们一般通过构造方法或者 setter 方法注入底层对象。</p>
<ol>
<li><p>设值注入：依赖的对象通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。</p>
</li>
<li><p>构造注入：依赖的对象是通过构造器传入，发生在实例化 Bean 的时候。</p>
</li>
</ol>
<p><em>主要采用设值注入，性能更好更易读。但对于依赖关系无需变化的 Bean 采用构造注入。所有的依赖关系全部在构造器内设定。</em></p>
<p>优势：使用依赖注入后，即使底层类发生变化，上层类代码也不必改动，大大降低了代码的耦合度。</p>
<p>劣势：但这也导致了我们在初始化对象的过程中要书写复杂的代码。</p>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>( Inversion of Control ) 控制反转，将对象的管理权交给 IOC 容器。</p>
<p>Spring 框架内会定义一个 IOC 容器类，通过其来统一管理对象的生命周期：创建、资源存取、注销；并自动维护对象间的依赖关系。用户只需要配置 XML 文件或者添加注解标明类之间的映射关系，初始化过程中的代码将由 IOC 容器自动完成。</p>
<p>IOC 容器底层通过工厂模式和 Java 反射机制来实现：</p>
<ol>
<li>IOC 容器根据 XML 配置文件或者注解读取 Bean 中保存的对象信息。</li>
<li>IOC 容器充当工厂类，利用 Java 反射机制读取需要生成哪些对象，来自动生成相应的对象。</li>
</ol>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h3><p>在 Spring 框架中已经定义了 ApplicationContext 和 BeanFactory 作为 IOC 容器类。其中 ApplicationContext是 BeanFactory 的子类，提供了事件发布、国际化信息支持等其他高级特性。</p>
<p>我们可以通过 IOC 容器类的 setBean 方法创建 Bean ，也可以通过 getBean 方法把 Bean 实例化并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置文件，创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// IOC 容器根据 Bean 创建对象实例</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">newUser</span> <span class="operator">=</span> (Person) context.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用对象方法</span></span><br><span class="line">    System.out.print(newUser.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>Java Bean 就是程序中被管理的对象在 IOC 容器中的代理，记录了对象信息。</p>
<p>Bean 包含以下参数：Bean 名称(name) 、所代理的类(class) 、以及作用域(scope)。</p>
<h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><ul>
<li><strong>singleton 单例模式</strong>（默认）： 在整个 IoC 容器中，Bean 只有一个对象实例。</li>
<li><strong>prototype 原型模式</strong>： 每次调用 Ioc 容器的 getBean 方法，都将产生一个新的对象实例。</li>
<li><strong>request</strong>： 对于每次 HTTP 请求，Bean 都将产生一个新的对象实例。</li>
<li><strong>session</strong>： 对于每个 HTTP Session，Bean 都将产生一个新的对象实例。</li>
<li><strong>global session</strong>： 对于每个全局的 HTTP Session，Bean 都将产生一个新的对象实例。</li>
</ul>
<h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p>Spring 对 Bean 方法进行了抽象和封装，开发者只需要进行配置和调用简单接口，具体实现都交付给 Spring 工厂来管理。</p>
<p>在调用 getBean 方法时，Spring 的工作流大致可分为以下两步：</p>
<ol>
<li>解析：读 xml 配置，扫描类文件，从配置或者注解中获取 Bean 的定义信息，注册一些扩展功能。</li>
<li>加载：通过解析完的定义信息获取 Bean 实例。</li>
</ol>
<p>获取 BeanName，对传入的 name 进行解析，转化为可以从 Map 中获取到 BeanDefinition 的 bean name。<br>合并 Bean 定义，对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。<br>实例化，使用构造或者工厂方法创建 Bean 实例。<br>属性填充，寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。<br>初始化，调用自定义的初始化方法。<br>获取最终的 Bean，如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>三个类 A、B、C，然后 A 关联 B，B 关联 C，C 又关联 A，这就形成了一个循环依赖。如果是方法调用是不算循环依赖的，循环依赖必须要持有引用。</p>
<ol>
<li>构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。</li>
</ol>
<p>无法解决</p>
<ol start="2">
<li>设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。</li>
</ol>
<p>Spring 框架只支持单例下的设值循环依赖。原型模式检测到循环依赖会直接抛出 BeanCurrentlyInCreationException 异常。</p>
<hr>
<h2 id="IOC-注解详解"><a href="#IOC-注解详解" class="headerlink" title="IOC 注解详解"></a>IOC 注解详解</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为类添加 <code>@Configuration</code> 注解，表示该类为配置类。起到类似 XML 文件的作用，配置 IOC 容器用来管理 Bean。</p>
<h4 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h4><p>为配置类添加 <code>@ComponentScan</code> 注解，启用组件扫描。配置类将根据注解向 IOC 容器添加 Bean，默认扫描本类中的 @Bean 方法。</p>
<p>可以指定需要扫描的包，这会扫描包内的所有组件。如 <code>@ComponentScan(value=&quot;com.company.project&quot;)</code>。</p>
<h3 id="注册-setBean"><a href="#注册-setBean" class="headerlink" title="注册 (setBean)"></a>注册 (setBean)</h3><ul>
<li><strong>为类添加 <code>@Component</code> 注解</strong></li>
</ul>
<p>表示该类型被注册为 Bean 。Bean 的名称默认为类名的首字母小写，作用域默认为单例模式。</p>
<ol>
<li><p>可以为注册的 Bean 指定名称，等同于 <code>@Component(&quot;car&quot;)</code> 。</p>
</li>
<li><p>可以为注册的 Bean 指定作用域，如 <code>@Component(&quot;prototype&quot;)</code> 。</p>
</li>
</ol>
<p>在 Spring MVC 中，我们可以把 <code>@Component</code> 细化为：</p>
<ul>
<li><code>@Controller</code> 注解：表示展示层的 Bean</li>
<li><code>@Service</code> 注解：表示业务层的 Bean</li>
<li><code>@Repository</code> 注解：表示数据访问层的 Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> FrameWork frameWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为方法添加 <code>@Bean</code> 注解</strong></li>
</ul>
<p>方法返回类型将被注册为 Bean。Bean 的名称默认为方法名，作用域默认为单例模式。</p>
<ul>
<li><p>可以为注册的 Bean 指定名称，等同于 <code>@Bean(name = &quot;myFoo&quot;)</code> 。</p>
</li>
<li><p>主要用在 @Configuration 注解的类里，也可以用在 @Component 注解的类里。</p>
</li>
</ul>
<h3 id="装配-getBean"><a href="#装配-getBean" class="headerlink" title="装配 (getBean)"></a>装配 (getBean)</h3><ul>
<li><strong>为对象添加 <code>@Autowired</code> 注解</strong></li>
</ul>
<p>表示自动装配。在使用对象时 Spring 将<strong>根据类型</strong>自动查找 Bean 去创建对象，无法找到 Bean 则抛出异常。</p>
<ol>
<li><p>如果想要在无法找到 Bean 时返回 null 值，则将注解改为 <code>@Autowired(required=false)</code> 。</p>
</li>
<li><p>如果自动装配对象的类型是接口，而配置的实现类 Bean 有多个。则必须用 <code>@Qualifier</code> 注解来指定 Bean 的名称。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Vehicle vehicle;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>为对象添加 <code>@Resource</code> 注解</strong></li>
</ul>
<p>表示自动装配。默认按对象名称去查找 Bean，找不到再按类型去查找 Bean。</p>
<ol>
<li><p>注解可以指定按名称或者类型去查找 Bean，如 <code>@Resource(name=&quot;car&quot;)</code> 或者 <code>@Resource(type=Car.class)</code>。</p>
</li>
<li><p>也可以同时按名称和类型查找 Bean，任何一个不匹配都将报错。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Vehicle vehicle;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>@Autowired 是 Spring 的注解，@Resource 是 J2EE 的注解。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-SpringAOP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/11/07/SpringAOP/" class="article-date">
  	<time datetime="2024-11-07T02:51:39.000Z" itemprop="datePublished">2024-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/11/07/SpringAOP/">
        &#39;SpringAOP&#39;
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><hr>
<h2 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h2><h3 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h3><p>( Aspect Orient Programming ) 面向切面编程，是面向对象编程(OOP) 的一种补充。</p>
<p>在 Java 程序自上而下处理主业务时，也会经常处理一些和主业务逻辑无关的问题（比如在接收用户访问请求时，计算程序响应该请求的运行时间）。这些代码如果和主逻辑代码混淆，会导致后期难以维护。</p>
<p>AOP 就是将这些横切性问题和主逻辑解耦。保证开发者不修改主逻辑代码的前提下，能为系统中的业务组件添加删除、或复用某种功能。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP 的本质是修改业务组件实际执行方法的源代码。即代理类 A 封装了目标类 B ，外部调用 B 的目标方法时会被代理类 A 拦截，代理类 A 一方面执行切面逻辑，一方面把调用转发给目标类 B ，执行目标方法。</p>
<p>该过程是代理模式的实现，代理方式有以下两种：</p>
<ul>
<li><p><strong>静态 AOP</strong> ：在编译阶段对程序源代码进行修改，生成静态的 AOP 代理类（字节码文件已被修改）。性能更好。</p>
</li>
<li><p><strong>动态 AOP</strong> ：在运行阶段动态生成代理对象。灵活性更好。</p>
</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>Spring 中的 AOP 是通过动态代理实现的，有以下两种方式：</p>
<ul>
<li><strong>JDK 动态代理</strong></li>
</ul>
<p>利用反射机制生成一个实现代理接口的类，在调用具体方法前调用 InvokeHandler 来处理。</p>
<p>JDK 代理只能对实现接口的类生成代理。代理生成的是一个接口对象，因此代理类必须实现了接口，否则会抛出异常。</p>
<ul>
<li><strong>CGlib 动态代理</strong></li>
</ul>
<p>直接操作字节码对代理对象类的字节码文件加载并修改，生成子类来处理。</p>
<p>CGlib 代理针对类实现代理，对指定的类生成一个子类并覆盖其中的方法，因此不能代理 final 类。</p>
<hr>
<h2 id="AOP-注解详解"><a href="#AOP-注解详解" class="headerlink" title="AOP 注解详解"></a>AOP 注解详解</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对负责扫描组件的配置文件类(@Configuration) 添加 <code>@EnableAspectJAutoProxy</code> 注解，启用 AOP 功能。</p>
<p><strong>默认通过 JDK 动态代理方式进行织入。</strong>但必须代理一个实现接口的类，否则会抛出异常。</p>
<p>注解改为 <code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>：</p>
<p>通过 cglib 的动态代理方式进行织入。但如果拓展类的方法被 final 修饰，则织入无效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.company.project.service.Meal.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>对组件类(@component) 添加 <code>@Aspect</code> 注解，表示该类为切面类。</p>
<h4 id="增强类型"><a href="#增强类型" class="headerlink" title="增强类型"></a>增强类型</h4><p><strong>前置通知</strong></p>
<p>切面方法注解 <code>@Before</code> 表示目标方法调用前，执行该切面方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后置通知</strong></p>
<ul>
<li>切面方法注解 <code>@After</code> 表示目标方法返回或抛出异常后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterReturning</code> 只在目标方法返回后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterThrowing</code> 只在目标方法抛出异常后，执行该切面方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环绕通知</strong></p>
<p>切面方法注解 <code>@Around</code> 表示切面方法执行过程中，执行目标方法。</p>
<p>传入参数为 ProceedingJoinPoint 类对象，表示目标方法。在切面方法中调用其 proceed 方法来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">        pj.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切点声明"><a href="#切点声明" class="headerlink" title="切点声明"></a>切点声明</h4><p>在切面方法中需要声明切面方法要切入的目标方法，execution 指示器是我们定义切点时最主要使用的指示器。</p>
<p>格式为： <code>execution(返回数据类型 路径.类.方法(传入参数类型))</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>execution(* com.company.project.service.Meal.eat(..))</code></td>
<td>执行 Meal 类的 eat 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.eat(int,String))</code></td>
<td>执行 Meal 类的 eat(int,String) 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.*(..))</code></td>
<td>执行 Meal 类的所有方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（不包含子包）</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service..*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（包含子包）</td>
</tr>
<tr>
<td><code>execution(public * *(..))</code></td>
<td>执行所有目标类的所有 public 方法时切入</td>
</tr>
<tr>
<td><code>execution(* pre*(...))</code></td>
<td>执行所有目标类所有以 pre 为前缀的方法时切入</td>
</tr>
</tbody></table>
<p>还有一些其他指示器：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>within(com.company.project.service.*)</code></td>
<td>执行 service 包内的任意方法时切入</td>
</tr>
<tr>
<td><code>this(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的代理对象的任意方法时切入</td>
</tr>
<tr>
<td><code>target(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的目标对象的任意方法时切入</td>
</tr>
<tr>
<td><code>args(java.io.Serializable)</code></td>
<td>任何一个只接受一个参数，并且运行时所传入的参数是 Serializable 接口的方法</td>
</tr>
</tbody></table>
<ul>
<li>多个匹配条件之间使用链接符连接： <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</li>
<li>within 指示器表示可以选择的包，bean 指示器可以在切点中选择 bean 。</li>
</ul>
<p>如参数 <code>execution(String com.company.project.service.test1.IBuy.buy(double)) &amp;&amp; args(price) &amp;&amp; bean(girl)</code> </p>
<p>要求返回类型为 String ；参数类型为 double ；参数名为 price ；调用目标方法的 bean 名称为 girl 。</p>
<p><strong>简化代码</strong></p>
<p>对于类中要频繁要切入的目标方法，我们可以使用 <code>@Pointcut</code> 注解声明切点表达式，简化代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(String com.company.project.service.Meal.eat(double)) &amp;&amp; args(price) &amp;&amp; bean(people)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point2</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point2(price)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(ProceedingJoinPoint pj, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pj.proceed();</span><br><span class="line">            <span class="keyword">if</span> (price &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;can not afford&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;没有购买&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="常用-AOP"><a href="#常用-AOP" class="headerlink" title="常用 AOP"></a>常用 AOP</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p><code>@ControllerAdvice</code> &#x2F; <code>@RestControllerAdvice</code>: 标注当前类为所有 Controller 类服务</p>
</li>
<li><p><code>@ExceptionHandler</code>: 标注当前方法处理异常（默认处理 RuntimeException）<br><code>@ExceptionHandler(value = Exception.class)</code>: 处理所有异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleOtherException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;错误=%s,位置=%s&quot;</span>, e.toString(), e.getStackTrace()[<span class="number">0</span>].toString());</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.UNKNOWN_ERROR.getErrorCode(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(StreamPlatformException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleVenusException</span><span class="params">(StreamPlatformException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(e.getErrorCode(), e.getMessageToUser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(FormValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleFormValidationException</span><span class="params">(FormValidationException e)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        e.getResult().getAllErrors().forEach(objectError -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (objectError <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">                <span class="type">FieldError</span> <span class="variable">fieldError</span> <span class="operator">=</span> (FieldError) objectError;</span><br><span class="line">                message.append(<span class="string">&quot;参数&quot;</span>).append(fieldError.getField())</span><br><span class="line">                        .append(<span class="string">&quot;错误值为&quot;</span>).append(fieldError.getRejectedValue())</span><br><span class="line">                        .append(fieldError.getDefaultMessage());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                message.append(objectError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.PARAMETER_VALIDATION_ERROR.getErrorCode(),</span><br><span class="line">                String.format(ErrorCode.PARAMETER_VALIDATION_ERROR.getMessage(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul>
<li><strong>拦截器(Interceptor)</strong></li>
</ul>
<p>Java Web 中，在执行 Controller 方法前后对 Controller 请求进行拦截和处理。依赖于 web 框架，在 Spring 配置。在实现上基于 Java 的反射机制。</p>
<ul>
<li><strong>过滤器(Filter)</strong></li>
</ul>
<p>Java Web 中，在 request&#x2F;response 传入 Servlet 前，过滤信息或设置参数。依赖于 servlet 容器，在 web.xml 配置。在实现上基于函数回调。</p>
<blockquote>
<p>两者常用于修改字符编码、删除无用参数、登录校验等。Spring 框架中优先使用拦截器：功能接近、使用更加灵活。</p>
</blockquote>
<p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在配置中引入拦截器对象（单独编写拦截器类）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 导入拦截器对象，默认拦截全部</span></span><br><span class="line">    <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">myInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除配置</span></span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);               </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);                       </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 拦截配置</span></span><br><span class="line">    addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器类通过实现 HandlerInterceptor 接口或者继承 HandlerInterceptorAdapter 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 预处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 检查 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 重定向到登录页面</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 善后处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INTERCEPTOR POSTHANDLE CALLED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器类通过继承 Filter 类实现，直接添加注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>                                                                <span class="comment">// 作为组件，交给容器处理</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span>                                                     <span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/login/*&quot;,filterName = &quot;loginFilter&quot;)</span>           <span class="comment">// 设定过滤路径和名称</span></span><br><span class="line"><span class="meta">@Order(1)</span>                                                                 <span class="comment">// 设定优先级（值小会优先执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤器前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行内部逻辑</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">// 过滤器后执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Spring" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/11/06/Spring/" class="article-date">
  	<time datetime="2024-11-06T13:30:43.000Z" itemprop="datePublished">2024-11-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/11/06/Spring/">
        Spring
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是用于开发 Java 应用程序的开源框架，为解决企业应用开发的复杂性而创建。</p>
<ol>
<li>Spring 的基本设计思想是利用 IOC（依赖注入）和 AOP （面向切面）解耦应用组件，降低应用程序各组件之间的耦合度。</li>
<li>在这两者的基础上，Spring 逐渐衍生出了其他的高级功能：如 Security，JPA 等。</li>
</ol>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC 是 Spring 的子功能模块，专用于 Web 开发。</p>
<p>Spring MVC 基于 Servlet 实现，将 Web 应用中的数据业务、显示逻辑和控制逻辑进行分层设计。开发者可以直接调用 Spring MVC 框架中 Spring 解耦的组件，快速构建 Web 应用。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot 是用于简化创建 Spring 项目配置流程，快速构建 Spring 应用程序的辅助工具。Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能。但 在创建 Spring 项目时，Spring Boot 可以：</p>
<ol>
<li>自动添加 Maven 依赖，不需要在 pom.xml 中手动添加配置依赖。</li>
<li>不需要配置 XML 文件，将全部配置浓缩在一个 appliaction.yml 配置文件中。</li>
<li>自动创建启动类，代表着本工程项目和服务器的启动加载。</li>
<li>内嵌 Tomcat 、Jetty 等容器，无需手动部署 war 文件。</li>
</ol>
<hr>
<h2 id="Spring-Boot-配置"><a href="#Spring-Boot-配置" class="headerlink" title="Spring Boot 配置"></a>Spring Boot 配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在Spring Boot中，引入的所有包都是 starter 形式：</p>
<p>spring-boot-starter-web-services，针对 SOAP Web Services<br>spring-boot-starter-web，针对 Web 应用与网络接口<br>spring-boot-starter-jdbc，针对 JDBC<br>spring-boot-starter-data-jpa，基于 Hibernate 的持久层框架<br>spring-boot-starter-cache，针对缓存支持</p>
<h3 id="默认映射路径"><a href="#默认映射路径" class="headerlink" title="默认映射路径"></a>默认映射路径</h3><ul>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code></li>
<li><code>classpath:/public/</code></li>
</ul>
<p>优先级顺序：META-INF&#x2F;resources &gt; resources &gt; static &gt; public</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>位于 resources 文件夹下，支持以下两种格式。由 Spring Boot 自动加载。</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment">#访问前缀</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#数据库驱动</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jc.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="comment">#数据库用户名</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据库密码</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">wdh19970506</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="comment">#配置文件路径</span></span><br><span class="line"><span class="attr">mybatis_config_file</span>=<span class="string">mybatis-config.xml</span></span><br><span class="line"><span class="comment">#SQL语句配置路径</span></span><br><span class="line"><span class="attr">mapper_path</span>=<span class="string">/mapper/**.xml</span></span><br><span class="line"><span class="comment">#实体类所在包</span></span><br><span class="line"><span class="attr">type_alias_package</span>=<span class="string">com.example.demo.entity</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDBC 连接 Mysql5 驱动： com.mysql.jdbc.Driver</li>
<li>JDBC 连接 Mysql6 驱动： com.mysql.cj.jdbc.Driver , URL 必须要指定时区 serverTimezone ！</li>
</ul>
<p><strong>多重配置</strong></p>
<p>在 Spring Boot 中，我们往往需要配置多个不同的配置文件去适应不同的环境：</p>
<ul>
<li><code>application-dev.properties</code> 开发环境</li>
<li><code>application-test.properties</code> 测试环境</li>
<li><code>application-prod.properties</code> 生产环境</li>
</ul>
<p>只需要在程序默认配置文件 <code>application.properties</code> 中设置环境，就可以使用指定的配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p><code>@SpringBootApplication</code> 类：作为程序入口，在创建 Spring Boot 项目时自动创建。</p>
<p>等同于 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code> ，会自动完成配置并扫描路径下所有包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring 需要定义调度程序 servlet ，映射和其他支持配置。我们可以使用 web.xml 文件或 Initializer 类来完成此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.setConfigLocation(<span class="string">&quot;com.pingfangushi&quot;</span>);</span><br><span class="line">          container.addListener(<span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(context));</span><br><span class="line">          ServletRegistration.<span class="type">Dynamic</span> <span class="variable">dispatcher</span> <span class="operator">=</span> container</span><br><span class="line">          .addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要将 <code>@EnableWebMvc</code> 注释添加到 <code>@Configuration</code> 类，并定义一个视图解析器来解析从控制器返回的视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">InternalResourceViewResolver</span> <span class="variable">bean</span></span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalResourceViewResolver</span>();</span><br><span class="line">      bean.setViewClass(JstlView.class);</span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JDBC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/31/JDBC/" class="article-date">
  	<time datetime="2024-10-31T14:09:23.000Z" itemprop="datePublished">2024-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/31/JDBC/">
        JDBC
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><hr>
<h2 id="JDBC-简介"><a href="#JDBC-简介" class="headerlink" title="JDBC 简介"></a>JDBC 简介</h2><p>JDBC 是 Java EE 提供的数据库接口，负责连接 java 程序和后台数据库。安装数据库驱动程序后，开发者可以按照 JDBC 规范直接在 Java 程序上对数据库进行操作，由数据库厂商负责具体实现。</p>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><ol>
<li><p>下载 MySQL 驱动包，解压后得到 jar 库文件：<a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/connector/j/">http://dev.mysql.com/downloads/connector/j/</a></p>
</li>
<li><p>打开 IDE，在对应项目中 configure build path 导入 jar 库文件。</p>
</li>
</ol>
<hr>
<h2 id="JDBC-编程"><a href="#JDBC-编程" class="headerlink" title="JDBC 编程"></a>JDBC 编程</h2><p>JDBC 常用工具类位于 sql 包内，使用时需导入：<code>import java.sql.*</code> 。使用时可能 抛出 SQLException 异常。</p>
<h3 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h3><p>JDBC 首先要使用反射机制加载驱动类，并创建其对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);          <span class="comment">// MySQL 数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">// Oracle 数据库驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="连接数据库-Connection"><a href="#连接数据库-Connection" class="headerlink" title="连接数据库 Connection"></a>连接数据库 Connection</h3><p>JDBC 由 Connection 类负责连接数据库，参数中输入数据库 URL、账号、密码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接本地 RUNOOB 数据库，需设置时区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;            <span class="comment">// 数据库账号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;          <span class="comment">// 数据库密码</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(DB_URL,USER,PASS);    <span class="comment">// 建立连接</span></span><br><span class="line">conn.close();                                                       <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></figure>

<h3 id="执行语句-Statement"><a href="#执行语句-Statement" class="headerlink" title="执行语句 Statement"></a>执行语句 Statement</h3><p>JDBC 由 Statement 类负责发送 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> = conn.createStatement();         <span class="comment">// 创建 Statement 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// executeQuery 执行查询操作，返回 ResultSet 结果集</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM websites&quot;</span>); </span><br><span class="line"><span class="comment">// executeUpdate 执行更新操作，返回 int 数据表示受影响行数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stmt.executeUpdate(<span class="string">&quot;DELETE * FROM websites&quot;</span>); </span><br><span class="line">     </span><br><span class="line">stmt.close();                                      <span class="comment">// 关闭 Statement 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="返回查询结果-ResultSet"><a href="#返回查询结果-ResultSet" class="headerlink" title="返回查询结果 ResultSet"></a>返回查询结果 ResultSet</h3><p>JDBC 由 ResultSet 类返回 select 语句执行结果，读取 executeQuery 方法返回的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);             <span class="comment">// 获取返回结果</span></span><br><span class="line">               </span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;                                  <span class="comment">// 输出返回结果</span></span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JDBC-进阶"><a href="#JDBC-进阶" class="headerlink" title="JDBC 进阶"></a>JDBC 进阶</h2><h3 id="预编译-PreparedStatement"><a href="#预编译-PreparedStatement" class="headerlink" title="预编译 PreparedStatement"></a>预编译 PreparedStatement</h3><p>PreparedStatement 类继承自 Statement 类，在 JDBC 开发中用来取代前者。有以下两个优势：</p>
<ol>
<li>可对 SQL 语句进行预编译，可以灵活地修改 SQL 语句，提高开发效率。</li>
<li>把用户输入单引号转义，防止恶意注入，保护数据库安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.preparedStatement(sql);   <span class="comment">// 创建对象并预编译</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>, <span class="number">755</span>);                                          <span class="comment">// 在第一个占位符(?)位置插入数字</span></span><br><span class="line">stmt.setString(<span class="number">2</span>, <span class="string">&quot;MrJoker&quot;</span>);                                 <span class="comment">// 在第二个占位符(?)位置插入字符串</span></span><br><span class="line">stmt.executeUpdate();                                         <span class="comment">// 更新并执行</span></span><br></pre></td></tr></table></figure>

<h3 id="批处理-executeBath"><a href="#批处理-executeBath" class="headerlink" title="批处理 executeBath"></a>批处理 executeBath</h3><p>PreparedStatement 类可以通过 executeBath 方法批量处理 SQL 语句，进一步提高效率。其返回值为一个 int[] 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    stmt.setInt(<span class="number">1</span>, i);</span><br><span class="line">    stmt.setString(<span class="number">2</span>, (i + <span class="string">&quot;号士兵&quot;</span>));</span><br><span class="line">    stmt.addBatch();                                           <span class="comment">// 语句添加到批处理序列中</span></span><br><span class="line">&#125;</span><br><span class="line">preparedStatement.executeBatch();                              <span class="comment">// 语句发送给数据库批量处理</span></span><br><span class="line">preparedStatement.clearBatch();                                <span class="comment">// 清空批处理序列</span></span><br></pre></td></tr></table></figure>


<h3 id="大文本和二进制数据"><a href="#大文本和二进制数据" class="headerlink" title="大文本和二进制数据"></a>大文本和二进制数据</h3><ul>
<li><p>clob 用于存储大文本</p>
</li>
<li><p>blob用于存储二进制数据</p>
</li>
</ul>
<hr>
<h2 id="JDBC-示例"><a href="#JDBC-示例" class="headerlink" title="JDBC 示例"></a>JDBC 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于 JDK 1.8 以后版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> useMethod（）&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;                  </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;                    </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);                                </span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);    </span><br><span class="line">            stmt = conn.preparedStatement(<span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>);  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();        </span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));   </span><br><span class="line">            &#125;</span><br><span class="line">            rs.close(); </span><br><span class="line">            stmt.close(); </span><br><span class="line">            conn.close();                    </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;         <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;                                                 </span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                <span class="keyword">if</span>(stmt != <span class="literal">null</span>) stmt.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;&#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-IO流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/IO%E6%B5%81/" class="article-date">
  	<time datetime="2024-10-30T15:49:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/IO%E6%B5%81/">
        IO流
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO流"><a href="#IO流" class="headerlink" title="#IO流"></a>#IO流</h2><p>##总览</p>
<p>流的分类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>分类1</th>
<th>分类2</th>
</tr>
</thead>
<tbody><tr>
<td>单位</td>
<td>字节流</td>
<td>字符流</td>
</tr>
<tr>
<td>流向</td>
<td>输入流</td>
<td>输出流</td>
</tr>
<tr>
<td>功能</td>
<td>节点流</td>
<td>处理流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>流名称</th>
<th>字节输入</th>
<th>字节输出</th>
<th>字符输入</th>
<th>字符输出</th>
</tr>
</thead>
<tbody><tr>
<td>4大基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>文件流</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td>-</td>
<td>-</td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>System</td>
<td>System.in</td>
<td>System.out</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>打印流</td>
<td>-</td>
<td>PrintStream</td>
<td>-</td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>缓存流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>数据流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong>内存流</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>随机访问流</td>
<td>-</td>
<td>RandomAccessFile</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>##四大抽象类</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><blockquote>
<p>说明：继承自InputStream的流都是用于向程序中输入数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract int read()	//从输入流中读取数据的下一个字节, 返回读到的字节值.若遇到流的末尾,返回-1
public int read(byte[] b)	//从输入流中读取 b.length 个字节的数据并存储到缓冲区数组b中.返回的是实际读到的字节总数
public int read(byte[] b, int off, int len)	//读取 len 个字节的数据,并从数组b的off位置开始写入到这个数组中
public void close()	//关闭此输入流并释放与此流关联的所有系统资源
public int available()	//返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数
public long skip(long n)	//跳过和丢弃此输入流中数据的 n 个字节，返回实现路过的字节数。
</code></pre>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><blockquote>
<p>说明：继承自OutputStream的流是程序用于向外输出数据的，且数据的单位为字节(8位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public abstract void write(int b)	//将指定的字节写入此输出流
public void write(byte[] b)	//将 b.length 个字节从指定的 byte 数组写入此输出流
public void write(byte[] b, int off, int len)	//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流
public void flush()	//刷新此输出流并强制写出所有缓冲的输出字节
pulbic void close()	//关闭此输出流并释放与此流有关的所有系统资源
</code></pre>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><blockquote>
<p>说明：继承自Reader的流都是用于向程序中输入数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public int read()	//读取单个字符的编码，返回作为整数读取的字符，如果已到达流的末尾返回-1
public int read(char[] cbuf)		//将字符读入数组，返回读取的字符数
public abstract int read(char[] cbuf, int off, int len)	//读取 len 个字符的数据，并从数组cbuf的off位置开始写入到这个数组中
public abstract void close()	//关闭该流并释放与之关联的所有资源
public long skip(long n) 	//跳过n个字符
int available() 	//还可以有多少能读到的字节数
</code></pre>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><blockquote>
<p>说明：继承自Writer的流是程序用于向外输出数据的，且数据的单位为字符(16位)</p>
</blockquote>
<p>核心方法：</p>
<pre><code>public void write(int c)		//写入单个字符
public void write(char[] cbuf)	//写入字符数组
public abstract void write(char[] cbuf, int off, int len)	//写入字符数组的某一部分
public void write(String str)	//写入字符串
public void write(String str, int off, int len)	//写字符串的某一部分
public abstract void close()	//关闭此流，但要先刷新它
public abstract void flush()	//刷新该流的缓冲，将缓冲的数据全写到目的地
</code></pre>
<hr>
<p>##节点流<br>###文件流</p>
<blockquote>
<p>说明：文件流主要用来操作文件</p>
</blockquote>
<ul>
<li><p><strong>FileInputStream</strong>:继承自InputStream</p>
</li>
<li><p><strong>FileOutputStream</strong>继承自OutputStream<br>FileOutputStream(String name, boolean append)  指定文件名和是否以追回方式写入</p>
</li>
<li><p><strong>FileReader</strong>继承自Reader<br>核心方法:</p>
<pre><code>1、构造方法
    FileReader(File file)
    FileReader(String fileName)
2、成员方法
    int read()	//每次读取一个字符，末尾-1返回值就是读入的内容
    int read(char[] cbuf)	//每次读取一组字符，最多读数组长度个，末尾-1返回值实际读取的个数
    int read(char[] cbuf,int off, int len)	//每次读取一组字符，最多len个，数据存入数组从off开始，末尾-1返回值实际读取的个数
    void close()
</code></pre>
</li>
<li><p><strong>FileWriter</strong>继承自Writer<br>核心方法:</p>
<pre><code>1、构造方法
    FileWriter(File file)
    FileWriter(File file,  boolean append)
    FileWriter(String fileName)
    FileWriter(String fileName, boolean append)	//构造方法来指定是否使用追加模式
2、成员方法
    void write(int c) 
    void write(char[] cbuf,int off, int len)
    void write(String str, int off,  int len)
    void flush()
    void close()
</code></pre>
</li>
</ul>
<p>###内存流</p>
<blockquote>
<p>说明：内存流主要用来操作内存，输入和输出可以从文件中来，也可以将设置在内存之上（内存：相当于长度可变的字节数组）</p>
</blockquote>
<p>分类：<br><strong>ByteArrayInputStream</strong>类：主要完成将内容从内存读入程序之中</p>
<pre><code>数据&lt;&lt;&lt;---------ByteArrayInputStream&lt;&lt;&lt;---------内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayInputStream（byte[] b）
ByteArrayInputStream(byte[] b,int off,int len)
</code></pre>
<p>常用方法：</p>
<pre><code>read()
skip()
available()
</code></pre>
<p><strong>ByteArrayOutputStream</strong>类：主要是将数据写入到内存中</p>
<pre><code>数据---------&gt;&gt;&gt;ByteArrayOutputStream---------&gt;&gt;&gt;内存
</code></pre>
<p>构造方法：</p>
<pre><code>ByteArrayOutputStream（）
ByteArrayOutputStream（int size） ：指定缓冲区大小（byte）
</code></pre>
<p>常用方法：</p>
<pre><code>byte[] toByteArray():将内存流转换为字节数组
toString（）
write（int）
write（byte[] bytes）
write（byte[] bytes ，int off，int len） 
writeTo（OutputStream）
</code></pre>
<p><strong>注意：内存流不需要关闭</strong></p>
<p>##处理流(过滤流)<br>###缓冲流</p>
<blockquote>
<p>说明：缓冲流是处理流的一种,建立在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，还增加了一些新的方法</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>1、对于缓冲输出流，写出的数据会先缓存在内存缓冲区中，关闭此流前要用flush()方法将缓存区的数据立刻写出</li>
<li>2、关闭过滤流时，会自动关闭过滤流所包装的所有底层流</li>
</ul>
<p><strong>BufferedInputStream</strong> 可以对任何的InputStream流进行包装</p>
<p><strong>BufferedOutputStream</strong> 可以对任何的OutputStream流进行包装</p>
<p><strong>BufferedReader</strong> 可以对任何的Reader流进行包装</p>
<blockquote>
<p>新增了readLine()方法用于一次读取一行字符串(以‘\r’或‘\n’认为一行结束)返回一行 如果没有返回null</p>
</blockquote>
<p><strong>BufferedWriter</strong> 可以对任何的Writer流进行包装</p>
<blockquote>
<p>新增了newLine()方法，用于跨平台的写入换行符</p>
</blockquote>
<p>###Object流</p>
<blockquote>
<p>说明：JDK提供的ObjectOutputStream和ObjectInputStream类是用于存储和读取基本数据类型或对象的过滤流</p>
</blockquote>
<p><strong>序列化</strong>：用ObjectOutputStream类保存基本数据类型或对象的机制叫序列化</p>
<p><strong>反序列化</strong>：用ObjectInputStream类读取基本数据类型或对象的机制叫反序列化</p>
<p><strong>Serializable接口</strong></p>
<pre><code>作用：能被序列化的对象所对应的类必须实现java.io.Serializable这个标识性接口
注意：实现此接口的类，需要提供一个静态long类型的常量serialVersionUID，保证序列化与反序列化的一致性
</code></pre>
<p><strong>构造方法</strong>:</p>
<pre><code>public ObjectOutputStream(OutputStream out)
public ObjectInputStream(InputStream in)
</code></pre>
<p><strong>transient关键字</strong>:</p>
<pre><code>transient关键字修饰成员变量时，表示这个成员变量是不需要序列化的
static修饰的成员变量也不会被序列化
</code></pre>
<p>###打印流</p>
<blockquote>
<p>说明：向控制台输出数据</p>
</blockquote>
<p>PrintStream类：字节输出流</p>
<p>PrintWriter类：字符输出流</p>
<p>打印流示例（<strong>注意：write写入的是字节</strong>）：</p>
<pre><code>PrintStream ps = new PrintStream(&quot;src/print.txt&quot;);
    ps.write(355);// 字节 00000000 00000000 00000001 01100011
                    // 舍弃前三位---》01100011--》c
    ps.println(355);
    ps.flush();
    ps.close();
</code></pre>
<p><strong>注意</strong></p>
<pre><code>System.out就是PrintStream的一个实例
PrintStream和PrintWriter的输出操作不会抛出异常
</code></pre>
<p>构造方法:</p>
<pre><code>PrintStream(OutputStream out)
PrintStream(OutputStream out, boolean autoFlush)
PrintWriter(Writer out)
PrintWriter(Writer out, boolean autoFlush)
PrintWriter(OutputStream out)
PrintWriter(OutputStream out, boolean autoFlush)
</code></pre>
<p>###转换流</p>
<blockquote>
<p>作用：转换流用于在字节流和字符流之间转换。</p>
</blockquote>
<p>分类：</p>
<ul>
<li><p><strong>InputStreamReader</strong>类</p>
<pre><code>1）是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象
2）InputStreamReader需要和InputStream“套接”，它可以将字节流中读入的字节解码成字符
</code></pre>
</li>
<li><p><strong>OutputStreamWriter</strong>类</p>
<pre><code>1）是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流的输出对象
2）OutputStreamWriter需要和OutputStream“套接”，它可以将要写入字节流的字符编码成字节
</code></pre>
</li>
</ul>
<p>转换过程：</p>
<ul>
<li><p>写入数据</p>
<pre><code>程序---&gt;&gt;字符数据---&gt;&gt;字符流---&gt;&gt;OutputStreamWriter---&gt;&gt;字节流---&gt;&gt;文件
</code></pre>
</li>
<li><p>读出数据</p>
<pre><code>  程序&lt;&lt;---字符数据&lt;&lt;---字符流&lt;&lt;----InputStreamReader&lt;&lt;---字节流&lt;&lt;---文件
</code></pre>
</li>
</ul>
<p>###数据流</p>
<p><strong>DataInputStream</strong>类</p>
<blockquote>
<p>作用：读取简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>readInt() 读取一个基本数据类型数据
readInt() 读取一个基本数据类型数据
</code></pre>
<p><strong>DataOutputStream</strong>类</p>
<blockquote>
<p>作用：写出简单数据类型和字符串</p>
</blockquote>
<p>核心方法:</p>
<pre><code>writeInt(int i)
writeUTF(String s) 写入UTF-8编码的字符串
</code></pre>
<p>##RandomAccessFile类(随机访问文件)</p>
<blockquote>
<p>作用：完成随机读取功能，可以读取指定位置的内容</p>
</blockquote>
<p>构造方法：</p>
<pre><code>public RandomAccessFile(File file,  String mode) 
public RandomAccessFile(File file,  String mode) 
</code></pre>
<p>文件的打开模式</p>
<pre><code>“r” 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  
“rw” 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。  
</code></pre>
<p>常用方法:</p>
<pre><code>getFilePointer():返回子文件中当前的偏移量	
seek(long l):设置到此文件开头测量到的文件的偏移量 在该位置的下一个发生读、写操作
</code></pre>
<p>注意：</p>
<pre><code>RandomAccessFile raf = new RandomAccessFile(&quot;src/per.txt&quot;, &quot;rw&quot;);
//这里遍历的时候需注意要用getFilePointer()读取光标的位置
for (int i = 0; i &lt; raf.length(); i = (int) raf.getFilePointer()) &#123;
    //do ...			
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  	<time datetime="2024-10-30T15:43:45.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
        异常处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><hr>
<h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><p>Java 程序中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
<p>java 程序中所有的异常都继承自 Throwable 类，Throwable 类有两个子类 Error 类和 Exception 类：</p>
<ul>
<li><p><strong>Error 类</strong>：【错误】表示 java 程序在运行时产生的无法处理的故障（如堆栈溢出），错误出现时会导致程序无法正常执行并强制退出。</p>
</li>
<li><p><strong>Exception 类</strong>：【异常】表示 java 程序中产生的可以被处理的故障，异常出现时可以由程序进行处理。</p>
</li>
</ul>
<h3 id="RuntimeException-类"><a href="#RuntimeException-类" class="headerlink" title="RuntimeException 类"></a>RuntimeException 类</h3><p>【运行时异常】 Exception 类的子类。</p>
<p>表示 java 程序运行状态中发生的异常，在编译时无法被检测。在 java 程序运行时会由系统自动抛出，允许应用程序不进行处理。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术异常，以零做除数</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundException</td>
<td>数组越界异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>空指针异常，对象不存在</td>
</tr>
</tbody></table>
<h3 id="Checked-Exception-类"><a href="#Checked-Exception-类" class="headerlink" title="Checked Exception 类"></a>Checked Exception 类</h3><p>【可检查异常】Exception 类除 RuntimeException 以外其他子类的统称。</p>
<p>表示 java 程序编译时检测到的异常。出现时必须在程序中进行捕获或抛出，否则编译不会通过。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>IOException</td>
<td>IO 异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>找不到文件异常，继承自 IO 异常</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类异常</td>
</tr>
</tbody></table>
<hr>
<h2 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h2><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>状态信息</strong></p>
<p>Throwable &#x2F; Exception 类是有状态的（因此 Throwable 是接口而不能是类），记录了四个信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object backtrace;                          <span class="comment">// 栈的回溯点</span></span><br><span class="line"><span class="keyword">private</span> String detailMessage;                                <span class="comment">// 异常的信息：在创建异常时备注</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="built_in">this</span>;                              <span class="comment">// 异常的原因：导致该异常的异常，默认为自身</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;   <span class="comment">// 异常的发生顺序：以栈的形式存储</span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p>Throwable &#x2F; Exception 类含有四个构造方法，在创建时可以记录异常信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();                           <span class="comment">// 默认</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>);                  <span class="comment">// 记录异常信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);                          <span class="comment">// 记录异常原因</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>, e);               <span class="comment">// 记录详细信息和异常原因</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<p>Throwable &#x2F; Exception 类定义了多种常用方法用于获取异常数据，常用的有：</p>
<ul>
<li>getMessage 方法：获取异常的信息。</li>
<li>getStackTrace 方法：获取的异常发生顺序。</li>
<li>printStackTrace 方法：获取异常的发生顺序并打印（开发和调试阶段用来显示异常信息，帮助开发者找出错误）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    e.printStacTrace();                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>我们也可以通过继承并重写 Exception &#x2F; RuntimeException 类的方式，自定义异常类并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义异常，重写方法可任选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message,cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常转译"><a href="#异常转译" class="headerlink" title="异常转译"></a>异常转译</h3><p>在项目开发过程中，当 Sevice&#x2F;DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。程序可以捕获原始异常，然后再抛出一个新的业务异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;SQL Error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 throw</h3><p>当方法执行出现问题时，方法就会创建异常对象并抛出。开发者可以在程序中自行抛出异常；JVM 在执行程序时发现问题也会自动抛出异常。</p>
<ul>
<li><p><strong>throw 语句</strong>：开发者自行创建异常对象并抛出，等待程序进行异常处理。</p>
</li>
<li><p><strong>throws 语句</strong>：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;       </span><br><span class="line">    <span class="comment">// 把方法中的抛出异常交给上层处理     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> IndexOutOfBoundsException, IOException&#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 用户自定义异常并抛出</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 虚拟机自动发现异常也会抛出，必须出现在 try 代码块中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(txt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-catch"><a href="#捕获异常-catch" class="headerlink" title="捕获异常 catch"></a>捕获异常 catch</h3><p>当方法执行抛出异常时，必须由专门的代码块对异常进行处理。</p>
<ul>
<li><p><strong>try 语句</strong>：可能出现异常的代码块。</p>
</li>
<li><p><strong>catch 语句</strong>：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。</p>
</li>
<li><p><strong>finally 语句</strong>：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><p>如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理。但必须在方法中声明 throws。</p>
</li>
<li><p>try&#x2F;catch 代码中的 return 语句会在执行完 finally 后再返回，但 finally 中对返回变量的改变不会影响最终的返回结果。</p>
</li>
<li><p>finally 代码中应避免含有 return 语句或抛出异常，否则只会执行 finally 中的 return 语句，且不会向上级抛出异常。</p>
</li>
</ol>
<p><em>Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;               </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<!--

**异常处理类**

在 Spring Boot 中，所有异常统一由专门的异常处理类`@ControllerAdvice`处理。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制器异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorHandler.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入参数校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NotValidExceptionHandler</span><span class="params">(HttpServletRequest req, MethodArgumentNotValidException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rfc4918 - 11.2. 422: Unprocessable Entity          </span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> MiscUtil.getValidateError(bindingResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.UNPROCESSABLE_ENTITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//404异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NoHandlerFoundExceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">404</span>, <span class="string">&quot;页面不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他默认异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">defaultHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-概念区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/" class="article-date">
  	<time datetime="2024-10-30T13:05:40.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/">
        概念区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###关键概念区别</p>
<p>####抽象类与接口</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>abstract  class</td>
<td>interface</td>
</tr>
<tr>
<td>概念</td>
<td>不能实例化的类，可能包含抽象方法</td>
<td>抽象方法和静态常量的集合</td>
</tr>
<tr>
<td>组成</td>
<td>抽象方法、普通方法、静态方法、变量、常量、静态变量、构造方法</td>
<td>抽象方法、静态常量</td>
</tr>
<tr>
<td>子类</td>
<td>子类继承抽象类</td>
<td>实现类实现接口</td>
</tr>
<tr>
<td>继承或实现关键字</td>
<td>extends</td>
<td>implements</td>
</tr>
<tr>
<td>局限性</td>
<td>单继承，可以多层继承</td>
<td>没有限制</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可以实现接口</td>
<td>接口不能继承抽象类</td>
</tr>
<tr>
<td>应用类</td>
<td>父类强制子类完成某些特定的功能，当然父类中也包含了共同的代码</td>
<td>约定、规范。 方法的描述，子类必须完成所有的方法</td>
</tr>
</tbody></table>
<p>####重写与重载</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重写</th>
<th>重载</th>
</tr>
</thead>
<tbody><tr>
<td>关键词</td>
<td>override</td>
<td>overload</td>
</tr>
<tr>
<td>概念</td>
<td>子类重写父类的方法</td>
<td>一个方法的多种展现形式</td>
</tr>
<tr>
<td>环境</td>
<td>子类和父类</td>
<td>一个类中</td>
</tr>
<tr>
<td>方法名</td>
<td>相同</td>
<td>相同</td>
</tr>
<tr>
<td>参数列表</td>
<td>相同</td>
<td>必须不同</td>
</tr>
<tr>
<td>返回值</td>
<td>相同</td>
<td>没有要求</td>
</tr>
<tr>
<td>访问权限</td>
<td>子类不能比父类更加严格</td>
<td>没有要求</td>
</tr>
<tr>
<td>异常</td>
<td>子类不能抛出比父类大的异常</td>
<td>没有要求</td>
</tr>
</tbody></table>
<hr>
<p>####this与super<br>总结：<strong>this是当前对象在堆空间的引用地址,super是当前对象的父类特征的引用</strong></p>
<p>super 只是记录对象内部的父类的特征(属性和方法)的一个引用</p>
<blockquote>
<p>这儿<strong>super不是指向父类对象的引用地址</strong>,new出来的才在堆里面分配空间有引用地址,这儿没有去new一个父类对象,只是执行了父类的构造函数将父类的特征生成了,但是属于New出来的那个子类对象的</p>
</blockquote>
<p>实践一下,你可以写</p>
<pre><code>public FatherClass getThis() 
&#123; 
return this; 
&#125; 
</code></pre>
<p>编译通过,没有任何问题<br>但是你写</p>
<pre><code>public FatherClass getSuper() 
&#123; 
return super; 
&#125; 
</code></pre>
<p>嘿嘿,编译出错! 为什么啦？</p>
<ul>
<li>因为super并不是一个堆空间里面的一个对象的引用地址,而this才是堆空间里面的一个对象的引用地址</li>
<li>super只能在对象内部使用,而this可以在对象内部使用也可以返回出对象外.</li>
<li>super是死的,编译的时候就定死了super的指向了,而this是活的,在运行时候决定其指向.</li>
</ul>
<p>解释一下:</p>
<blockquote>
<p>子类实例化对象,并没有去实例化他的父类对象,也就是说,那个子类对象里面并没有一个父类对象,那你说没有父类对象,为什么子类构造函数要执行父类的构造函数啦,那是因为需要创建父类的特征赋予子类,但是是由子类所有,而super就是用来区别是是否是父类对象的特征的.<br>重写父类方法属性,就是再创建了一个子类的特征,当你用this的时候,就覆盖了父类的特征了,但是父类特征还在那儿,用super就能访问到,但是只能在对象的内部使用.对象外面就只能看到覆盖了父类特征的子类特征了.</p>
</blockquote>
<table>
<thead>
<tr>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td>this.属性名。只能访问当前对象所拥有的属性(包括继承来的属性，如果继承的属性名和子类对象相同，若不指定则调用子类的，调用父类的需要显示指定：super.属性名)</td>
<td>super.属性名。可以访问父类非私有的属性</td>
</tr>
<tr>
<td>访问方法</td>
<td>与访问属性类似</td>
<td>与访问属性类似</td>
</tr>
<tr>
<td>调用构造器</td>
<td>this(有参或无参)调用本类中有参或无参的构造函数，必须放在构造函数的第一句</td>
<td>super(有参还是无参)调用父类的有参或是无参的构造方法，必须放在构造方法的第一行（注意：**在同一个构造函数里不能同时出现this()和super()**）</td>
</tr>
<tr>
<td>指代</td>
<td>this是当前对象在堆空间的引用地址</td>
<td>super是当前对象的父类特征的引用</td>
</tr>
<tr>
<td>作为参数</td>
<td>this可以作为参数，它代表了当前对象的引用</td>
<td>super不可以</td>
</tr>
<tr>
<td>使用环境</td>
<td>不可以在static环境中使用</td>
<td>不可以在static环境中使用</td>
</tr>
</tbody></table>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  	<time datetime="2024-10-30T13:01:29.000Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
        面向对象
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><hr>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li><p><strong>面向过程</strong>：根据解决问题的过程，直接设计系统。如 C 语言。</p>
</li>
<li><p><strong>面向对象</strong>：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。</p>
<ul>
<li><p>特性：封装、继承、多态。</p>
</li>
<li><p>优点：使系统更加灵活，易维护、易复用、易扩展。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。</p>
<p>成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  </span><br><span class="line">        inner.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">myrifle</span> <span class="operator">=</span> f.getRifle();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">getRifle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">Gun</span> &#123;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rifle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。</p>
<p>最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类或接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123; </span><br><span class="line">            <span class="comment">// 定义匿名内部类并直接使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 无需外部对象，直接创建内部类</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类继承父类后，无需定义也可使用父类定义好的 public&#x2F;protected 方法和属性。也可以进行扩展和方法的重写。</p>
<ul>
<li>父类的<strong>属性值</strong>不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。</li>
<li>父类的 <strong>static 方法</strong>不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。</li>
<li>父类的<strong>构造方法</strong>不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trunk</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123; </span><br><span class="line">    <span class="comment">// 重定义属性（未公开无法继承）</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;this is a trunk&quot;</span>;</span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="type">int</span> goods;</span><br><span class="line">    <span class="comment">// 扩展方法              </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.goods += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trunk</span><span class="params">(String brand)</span>&#123;    </span><br><span class="line">        <span class="built_in">super</span>(brand);        </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.go(loc);                            </span><br><span class="line">        System.out.print(<span class="string">&quot; with&quot;</span> + goods + <span class="string">&quot;goods&quot;</span>); </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。</em></p>
<hr>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Charge</span> <span class="keyword">extends</span> <span class="title class_">Move</span>, Fight&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h3><ul>
<li><strong>重载</strong>(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。</li>
<li><strong>重写</strong>(override)：子类定义完全相同的方法覆盖父类。</li>
</ul>
<p>重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。</p>
<p><code>Car mycar = new Trunk(&quot;Benz&quot;);</code></p>
<p>但不允许子类引用指向父类对象。</p>
<p><del><code>Trunk mycar = new Car(&quot;Benz&quot;);</code></del></p>
<p>如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。</p>
<p><code>Trunk newCar = (Trunk)mycar; </code></p>
<h3 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h3><ul>
<li><p><strong>调用普通方法</strong></p>
<p>子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。</p>
</li>
<li><p><strong>调用 static &#x2F; private &#x2F; final 以及构造方法</strong></p>
<p>特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。</p>
</li>
<li><p><strong>调用成员变量</strong></p>
<p>父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trunk</span>(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line"></span><br><span class="line">myCar.go(<span class="string">&quot;London&quot;</span>);                    <span class="comment">// (trunk) go to London with 0 goods</span></span><br><span class="line">myCar.showNum();                       <span class="comment">// (car) 1</span></span><br><span class="line">System.out.print(myCar.description);   <span class="comment">// (car) this is a car</span></span><br><span class="line"></span><br><span class="line"><span class="type">Trunk</span> <span class="variable">newCar</span> <span class="operator">=</span> (Trunk)mycar;           <span class="comment">// 强制类型转换</span></span><br><span class="line">System.out.print(newCar.description);  <span class="comment">// (trunk) this is a trunk</span></span><br></pre></td></tr></table></figure>


<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性。</li>
</ul>
<p>通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。</p>
<p>但是在性能上会有较大的损耗。</p>
<p><em>尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。</em></p>
<h4 id="反射机制运用"><a href="#反射机制运用" class="headerlink" title="反射机制运用"></a>反射机制运用</h4><p>类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。</p>
<ul>
<li><strong>Class 类</strong>：类</li>
<li><strong>Constructor 类</strong>：类的构造方法</li>
<li><strong>Field 类</strong>：类的属性</li>
<li><strong>Method 类</strong>：类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 对象 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种方式 返回对象的类 【已有对象，获取类无意义】</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第三种方式 返回路径下的类 【常用】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 信息 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getName());   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getConstructors();</span><br><span class="line">        <span class="comment">// 获取类的全部构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取类的指定构造方法（参数）</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getConstructor(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getFields(); </span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取类的指定属性（属性名）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有方法</span></span><br><span class="line">        Method[] methodArray = stuClass.getMethods(); </span><br><span class="line">        <span class="comment">// 获取类的全部方法                </span></span><br><span class="line">        Method[] methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取类的指定方法（方法名+形参类型）                  </span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;main&quot;</span>, String.class);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 在对象中使用 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();   <span class="comment">// 调用公有无参构造方法创建对象</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;X-man&quot;</span>);              <span class="comment">// 为对象的公有属性赋值</span></span><br><span class="line">        m.invoke(obj, <span class="string">&quot;X-man&quot;</span>);           <span class="comment">// 调用对象的公有方法</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><a href="/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?id=%E6%B3%9B%E5%9E%8B">泛型</a>在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：</p>
<p><em>在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	</span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); </span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/10/30/hello-world/" class="article-date">
  	<time datetime="2024-10-30T11:51:07.500Z" itemprop="datePublished">2024-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/10/30/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2025 Camellia
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>